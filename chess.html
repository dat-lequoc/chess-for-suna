<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Chess Game (Button Squares)</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
        }

        #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #board-container {
            display: grid;
            grid-template-areas:
                ". top ."
                "left board right"
                ". bottom .";
            grid-template-columns: auto 1fr auto; /* auto for labels, 1fr for board */
            grid-template-rows: auto 1fr auto;
            gap: 5px; /* Small gap between labels and board */
        }

        .labels {
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            color: #555;
        }
        .labels.files {
            flex-direction: row;
        }
        .labels.ranks {
            flex-direction: column;
        }
        .label {
            width: 60px; /* Match square size */
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #top-files    { grid-area: top; }
        #bottom-files { grid-area: bottom; }
        #left-ranks   { grid-area: left; }
        #right-ranks  { grid-area: right; }


        #chessboard {
            grid-area: board;
            width: 480px; /* 8 squares * 60px */
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 5px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .square-button {
            width: 100%; /* Fill grid cell */
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            border: none; /* Remove default button border */
            padding: 0;
            margin: 0;
            font-size: 40px; /* Piece size */
            cursor: pointer;
            position: relative; /* For pseudo-elements if needed */
            box-sizing: border-box; /* Include border in size */
            transition: background-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out;
        }

        .position-text {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 10px;
            color: rgba(0, 0, 0, 0.5);
            pointer-events: none;
            font-weight: bold;
            display: none; /* Completely hide the position text */
        }
        .square-button.dark .position-text {
            color: rgba(255, 255, 255, 0.7);
        }

        .square-button.light { background-color: #f0d9b5; }
        .square-button.dark { background-color: #b58863; }

        /* Piece Colors */
        .square-button.white { color: #ffffff; text-shadow: 1px 1px 2px #000000; }
        .square-button.black { color: #000000; text-shadow: 1px 1px 2px #aaaaaa;}

        /* --- Interaction States --- */

        .square-button.selected {
            /* Use a border or inset shadow to indicate selection */
            box-shadow: inset 0 0 0 4px rgba(0, 150, 0, 0.7);
        }

        .square-button.valid-move::after {
            /* Small dot for valid move */
            content: '';
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: rgba(0, 0, 0, 0.25);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Allow clicks on the button */
        }

        .square-button.capture-move {
             /* Dashed border for capture */
             border: 4px dashed rgba(200, 0, 0, 0.6);
        }
        /* Ensure capture border doesn't overlap selection shadow */
         .square-button.capture-move.selected {
             box-shadow: inset 0 0 0 4px rgba(0, 150, 0, 0.7), 0 0 0 4px rgba(200, 0, 0, 0.6);
             border: none; /* Override the dashed border if also selected */
         }


        #status {
            margin-top: 20px;
            font-size: 1.2em;
            font-weight: bold;
            min-height: 1.5em;
            color: #333;
        }

        #resetButton {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
         #resetButton:hover {
             background-color: #45a049;
         }

    </style>
</head>
<body>
    <div id="game-area">
        <div id="status">White's turn</div>
        <div id="board-container">
            <div id="top-files" class="labels files"></div>
            <div id="left-ranks" class="labels ranks"></div>
            <div id="chessboard"></div>
            <div id="right-ranks" class="labels ranks"></div>
            <div id="bottom-files" class="labels files"></div>
        </div>
        <button id="resetButton">Reset Game</button>
    </div>

    <script>
        const chessboardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');
        const topFilesLabel = document.getElementById('top-files');
        const bottomFilesLabel = document.getElementById('bottom-files');
        const leftRanksLabel = document.getElementById('left-ranks');
        const rightRanksLabel = document.getElementById('right-ranks');


        // --- Game State ---
        let board = []; // 8x8 array representing the board state
        let currentPlayer = 'white';
        let selectedPiece = null; // { element: buttonElement, piece, row, col }
        let validMoves = []; // Array of { row, col }
        let gameOver = false;
        let checkStatus = { white: false, black: false };
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let enPassantTarget = null; // { row, col } - The square *behind* a pawn that just moved two steps

        // --- Piece Representation ---
        const PIECES = {
            'P': { type: 'pawn', color: 'white', unicode: '♙' },
            'R': { type: 'rook', color: 'white', unicode: '♖' },
            'N': { type: 'knight', color: 'white', unicode: '♘' },
            'B': { type: 'bishop', color: 'white', unicode: '♗' },
            'Q': { type: 'queen', color: 'white', unicode: '♕' },
            'K': { type: 'king', color: 'white', unicode: '♔' },
            'p': { type: 'pawn', color: 'black', unicode: '♟' },
            'r': { type: 'rook', color: 'black', unicode: '♜' },
            'n': { type: 'knight', color: 'black', unicode: '♞' },
            'b': { type: 'bishop', color: 'black', unicode: '♝' },
            'q': { type: 'queen', color: 'black', unicode: '♛' },
            'k': { type: 'king', color: 'black', unicode: '♚' }
        };

        const initialBoardSetup = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // --- Initialization ---
        function initGame() {
            board = initialBoardSetup.map(row => row.map(p => p ? { ...PIECES[p] } : null));
            currentPlayer = 'white';
            selectedPiece = null;
            validMoves = [];
            gameOver = false;
            checkStatus = { white: false, black: false };
            castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            enPassantTarget = null;
            createLabels();
            renderBoard();
            updateStatusDisplay();
        }

        function createLabels() {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['8', '7', '6', '5', '4', '3', '2', '1']; // Reversed for display

            topFilesLabel.innerHTML = '';
            bottomFilesLabel.innerHTML = '';
            leftRanksLabel.innerHTML = '';
            rightRanksLabel.innerHTML = '';

            files.forEach(file => {
                const topLabel = document.createElement('div');
                topLabel.classList.add('label');
                topLabel.textContent = file;
                topFilesLabel.appendChild(topLabel);

                const bottomLabel = document.createElement('div');
                bottomLabel.classList.add('label');
                bottomLabel.textContent = file;
                bottomFilesLabel.appendChild(bottomLabel);
            });

            ranks.forEach(rank => {
                const leftLabel = document.createElement('div');
                leftLabel.classList.add('label');
                leftLabel.textContent = rank;
                leftRanksLabel.appendChild(leftLabel);

                const rightLabel = document.createElement('div');
                rightLabel.classList.add('label');
                rightLabel.textContent = rank;
                rightRanksLabel.appendChild(rightLabel);
            });
        }

        // --- Rendering ---
        function renderBoard() {
            chessboardElement.innerHTML = ''; // Clear previous state
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const squareButton = document.createElement('button');
                    squareButton.classList.add('square-button');
                    squareButton.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    squareButton.dataset.row = r;
                    squareButton.dataset.col = c;

                    // Create position text element (algebraic notation)
                    const positionText = document.createElement('span');
                    positionText.classList.add('position-text');
                    positionText.textContent = files[c] + (8 - r); // e.g., "e4", "a8"
                    
                    const piece = board[r][c];
                    if (piece) {
                        squareButton.textContent = piece.unicode;
                        squareButton.classList.add(piece.color); // Add 'white' or 'black' class
                        squareButton.classList.add('has-piece'); // Generic class if needed
                        squareButton.dataset.type = piece.type; // Store type for potential future use
                    } else {
                        squareButton.textContent = ''; // Or use &nbsp; if needed for layout stability
                    }

                    squareButton.appendChild(positionText);
                    chessboardElement.appendChild(squareButton);
                }
            }
            // Re-attach event listener using event delegation
            chessboardElement.removeEventListener('click', handleSquareClick); // Prevent duplicates
            chessboardElement.addEventListener('click', handleSquareClick);
        }

        // --- Event Handling ---
        function handleSquareClick(event) {
            if (gameOver) return;

            const targetButton = event.target.closest('.square-button');
            if (!targetButton) return; // Clicked outside a button (shouldn't happen with this structure)

            const row = parseInt(targetButton.dataset.row);
            const col = parseInt(targetButton.dataset.col);
            const clickedPieceData = board[row][col];

            if (selectedPiece) {
                // Attempting to make a move
                const isValidTarget = validMoves.some(move => move.row === row && move.col === col);

                if (isValidTarget) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    clearSelectionAndHighlights();
                    switchPlayer();
                    // Check for game end conditions *after* switching player
                    updateCheckStatus();
                    checkGameEnd();
                    updateStatusDisplay();
                } else {
                    // Clicked somewhere else - deselect or select another piece
                    const previouslySelectedButton = selectedPiece.element; // Store before clearing
                    clearSelectionAndHighlights();
                    // If clicked on another piece of the current player (and not the same piece)
                    if (clickedPieceData && clickedPieceData.color === currentPlayer && targetButton !== previouslySelectedButton) {
                        selectPiece(targetButton, clickedPieceData, row, col);
                    } else {
                        selectedPiece = null; // Just deselect
                    }
                }
            } else {
                // No piece selected, try selecting one
                if (clickedPieceData && clickedPieceData.color === currentPlayer) {
                    selectPiece(targetButton, clickedPieceData, row, col);
                }
            }
        }

        function selectPiece(squareButton, pieceData, row, col) {
             selectedPiece = { element: squareButton, piece: pieceData, row, col };
             validMoves = calculateValidMoves(pieceData, row, col);

             // Filter moves that would leave the king in check
             validMoves = validMoves.filter(move => {
                 const tempBoard = simulateMove(row, col, move.row, move.col);
                 return !isKingInCheck(currentPlayer, tempBoard);
             });

             highlightSelectedPiece(squareButton);
             highlightValidMoves(validMoves);
        }


        function clearSelectionAndHighlights() {
            // Remove selected class
            if (selectedPiece && selectedPiece.element) {
                selectedPiece.element.classList.remove('selected');
            }
            selectedPiece = null; // Clear the selection state *after* removing class

            // Remove all move indicator classes
            document.querySelectorAll('.square-button.valid-move, .square-button.capture-move').forEach(btn => {
                btn.classList.remove('valid-move', 'capture-move');
            });
            validMoves = []; // Clear the valid moves array
        }

        function highlightSelectedPiece(squareButton) {
            squareButton.classList.add('selected');
        }

        function highlightValidMoves(moves) {
            moves.forEach(move => {
                const targetButton = chessboardElement.querySelector(`.square-button[data-row='${move.row}'][data-col='${move.col}']`);
                if (targetButton) {
                    // Check if the move is a capture or en passant
                    const isCapture = board[move.row][move.col] !== null ||
                        (selectedPiece.piece.type === 'pawn' && move.col !== selectedPiece.col && board[move.row][move.col] === null && enPassantTarget && move.row === enPassantTarget.row && move.col === enPassantTarget.col);

                    if (isCapture) {
                        targetButton.classList.add('capture-move');
                    } else {
                        targetButton.classList.add('valid-move');
                    }
                }
            });
        }

        // --- Move Logic ---
        // (This function remains largely the same as it operates on the 'board' array)
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const pieceToMove = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol]; // Could be null
            let specialMove = null; // 'enpassant', 'castling', 'promotion'

            // --- Handle Special Moves ---

            // En Passant Capture
            if (pieceToMove.type === 'pawn' &&
                enPassantTarget &&
                toRow === enPassantTarget.row &&
                toCol === enPassantTarget.col)
            {
                const capturedPawnRow = currentPlayer === 'white' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = null; // Remove the captured pawn
                specialMove = 'enpassant';
            }

            // Castling
            if (pieceToMove.type === 'king') {
                const colDiff = toCol - fromCol;
                if (Math.abs(colDiff) === 2) {
                    specialMove = 'castling';
                    const rookCol = colDiff > 0 ? 7 : 0; // King-side or Queen-side
                    const rookTargetCol = colDiff > 0 ? 5 : 3;
                    const rook = board[fromRow][rookCol];
                    board[fromRow][rookTargetCol] = rook; // Move rook
                    board[fromRow][rookCol] = null;
                }
            }

            // --- Update Board State ---
            board[toRow][toCol] = pieceToMove;
            board[fromRow][fromCol] = null;

            // --- Update Game State ---

            // Reset en passant target for the next turn
            let nextEnPassantTarget = null;
            if (pieceToMove.type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                nextEnPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };
            }
            enPassantTarget = nextEnPassantTarget; // Set for the *next* player

            // Update Castling Rights
            if (pieceToMove.type === 'king') {
                castlingRights[pieceToMove.color].kingSide = false;
                castlingRights[pieceToMove.color].queenSide = false;
            } else if (pieceToMove.type === 'rook') {
                if (fromRow === (pieceToMove.color === 'white' ? 7 : 0)) { // Ensure rook is on its starting rank
                   if (fromCol === 0) castlingRights[pieceToMove.color].queenSide = false;
                   if (fromCol === 7) castlingRights[pieceToMove.color].kingSide = false;
                }
            }
            // If a rook is captured, update opponent's castling rights
            if (capturedPiece && capturedPiece.type === 'rook') {
                 const capturedColor = capturedPiece.color;
                 // Check if the captured rook was on its starting square
                 if (toRow === (capturedColor === 'white' ? 7 : 0)) {
                     if (toCol === 0) castlingRights[capturedColor].queenSide = false;
                     if (toCol === 7) castlingRights[capturedColor].kingSide = false;
                 }
            }


            // Pawn Promotion (Auto-Queen)
            if (pieceToMove.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                const promotedPieceKey = pieceToMove.color === 'white' ? 'Q' : 'q';
                board[toRow][toCol] = { ...PIECES[promotedPieceKey] };
                specialMove = 'promotion';
            }

            // --- Re-render the board based on the new state ---
            renderBoard(); // Re-draw the buttons based on the updated 'board' array
        }

        function switchPlayer() {
            currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
        }

        function updateStatusDisplay() {
            if (gameOver) {
                statusElement.textContent = gameOver;
                statusElement.style.color = 'red';
            } else {
                let statusText = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
                if (checkStatus[currentPlayer]) {
                    statusText += " (Check!)";
                    statusElement.style.color = 'orange';
                } else {
                     statusElement.style.color = '#333';
                }
                statusElement.textContent = statusText;
            }
        }

        // --- Rule Calculations ---
        // (These functions remain identical as they operate on the 'board' array)

        function calculateValidMoves(piece, row, col) {
            const moves = [];
            const color = piece.color;
            const opponentColor = (color === 'white') ? 'black' : 'white';

            const addMove = (r, c) => {
                if (isValidSquare(r, c)) {
                    const targetPiece = board[r][c];
                    if (targetPiece === null) {
                        moves.push({ row: r, col: c });
                        return true; // Square was empty, can continue sliding if applicable
                    } else if (targetPiece.color === opponentColor) {
                        moves.push({ row: r, col: c });
                        return false; // Capture, cannot continue sliding
                    } else {
                        return false; // Blocked by own piece
                    }
                }
                return false; // Off board
            };

            const addPawnMove = (r, c) => {
                 if (isValidSquare(r, c) && board[r][c] === null) {
                     moves.push({ row: r, col: c });
                     return true;
                 }
                 return false;
            };

            const addPawnCapture = (r, c) => {
                if (isValidSquare(r, c)) {
                    const targetPiece = board[r][c];
                    // Regular capture
                    if (targetPiece && targetPiece.color === opponentColor) {
                        moves.push({ row: r, col: c });
                    }
                    // En passant capture
                    else if (enPassantTarget && r === enPassantTarget.row && c === enPassantTarget.col && board[r][c] === null) { // Check target square is empty for EP
                         moves.push({ row: r, col: c });
                    }
                }
            };

            switch (piece.type) {
                case 'pawn':
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;

                    // Forward 1
                    if (addPawnMove(row + direction, col)) {
                        // Forward 2 (only from start row)
                        if (row === startRow) {
                            addPawnMove(row + 2 * direction, col);
                        }
                    }
                    // Captures
                    addPawnCapture(row + direction, col - 1);
                    addPawnCapture(row + direction, col + 1);
                    break;

                case 'rook':
                case 'bishop':
                case 'queen':
                    const directions = {
                        'rook': [[-1, 0], [1, 0], [0, -1], [0, 1]],
                        'bishop': [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                        'queen': [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
                    };
                    const pieceDirs = directions[piece.type];

                    pieceDirs.forEach(([dr, dc]) => {
                        let r = row + dr;
                        let c = col + dc;
                        while (addMove(r, c)) {
                            r += dr;
                            c += dc;
                        }
                    });
                    break;

                case 'knight':
                    const knightMoves = [
                        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                        [1, -2], [1, 2], [2, -1], [2, 1]
                    ];
                    knightMoves.forEach(([dr, dc]) => {
                        addMove(row + dr, col + dc);
                    });
                    break;

                case 'king':
                    const kingMoves = [
                        [-1, -1], [-1, 0], [-1, 1], [0, -1],
                        [0, 1], [1, -1], [1, 0], [1, 1]
                    ];
                    kingMoves.forEach(([dr, dc]) => {
                        addMove(row + dr, col + dc);
                    });

                    // Castling Logic
                    if (!isKingInCheck(color, board)) { // Cannot castle out of check
                        // King-side
                        if (castlingRights[color].kingSide &&
                            board[row][col + 1] === null &&
                            board[row][col + 2] === null &&
                            board[row][col + 3] && board[row][col+3].type === 'rook' && castlingRights[color].kingSide) // Check rook exists and right still valid
                         {
                            // Check if squares king moves *through* are attacked
                            if (!isSquareAttacked(row, col + 1, opponentColor, board) &&
                                !isSquareAttacked(row, col + 2, opponentColor, board)) {
                                moves.push({ row: row, col: col + 2 });
                            }
                        }
                        // Queen-side
                        if (castlingRights[color].queenSide &&
                            board[row][col - 1] === null &&
                            board[row][col - 2] === null &&
                            board[row][col - 3] === null &&
                            board[row][col - 4] && board[row][col-4].type === 'rook' && castlingRights[color].queenSide) // Check rook exists and right still valid
                        {
                             // Check if squares king moves *through* are attacked
                             if (!isSquareAttacked(row, col - 1, opponentColor, board) &&
                                 !isSquareAttacked(row, col - 2, opponentColor, board)) {
                                moves.push({ row: row, col: col - 2 });
                             }
                        }
                    }
                    break;
            }

            return moves;
        }

        function isValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function findKing(color, currentBoard) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        return { row: r, col: c };
                    }
                }
            }
            return null; // Should not happen in a valid game
        }

        function isSquareAttacked(targetRow, targetCol, attackerColor, currentBoard) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.color === attackerColor) {
                        // Calculate raw moves (ignoring check constraints for this check)
                        const rawMoves = calculateRawAttacks(piece, r, c, currentBoard);
                        if (rawMoves.some(move => move.row === targetRow && move.col === targetCol)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function calculateRawAttacks(piece, row, col, currentBoard) {
             const moves = [];
             const color = piece.color;

             const addAttack = (r, c) => {
                 if (isValidSquare(r, c)) {
                     moves.push({ row: r, col: c });
                     // Check if blocked for sliding pieces
                     return currentBoard[r][c] === null;
                 }
                 return false;
             };
              const addPawnAttack = (r, c) => {
                 if (isValidSquare(r, c)) {
                      moves.push({ row: r, col: c });
                 }
             };

             switch (piece.type) {
                 case 'pawn':
                     const direction = color === 'white' ? -1 : 1;
                     addPawnAttack(row + direction, col - 1);
                     addPawnAttack(row + direction, col + 1);
                     break;
                 case 'rook':
                 case 'bishop':
                 case 'queen':
                     const directions = {
                         'rook': [[-1, 0], [1, 0], [0, -1], [0, 1]],
                         'bishop': [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                         'queen': [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
                     };
                     const pieceDirs = directions[piece.type];
                     pieceDirs.forEach(([dr, dc]) => {
                         let r = row + dr;
                         let c = col + dc;
                         // Add the first square regardless of occupancy for attack check
                         if (isValidSquare(r,c)) moves.push({row: r, col: c});
                         // Continue sliding only if the first square was empty
                         while (currentBoard[r] && currentBoard[r][c] === null && isValidSquare(r + dr, c + dc)) {
                             r += dr;
                             c += dc;
                             moves.push({ row: r, col: c });
                         }
                     });
                     break;
                 case 'knight':
                     const knightMoves = [
                         [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                         [1, -2], [1, 2], [2, -1], [2, 1]
                     ];
                     knightMoves.forEach(([dr, dc]) => addAttack(row + dr, col + dc));
                     break;
                 case 'king':
                     const kingMoves = [
                         [-1, -1], [-1, 0], [-1, 1], [0, -1],
                         [0, 1], [1, -1], [1, 0], [1, 1]
                     ];
                     kingMoves.forEach(([dr, dc]) => addAttack(row + dr, col + dc));
                     break;
             }
             return moves;
        }


        function isKingInCheck(kingColor, currentBoard) {
            const kingPos = findKing(kingColor, currentBoard);
            if (!kingPos) return false; // King not found (shouldn't happen)
            const opponentColor = (kingColor === 'white') ? 'black' : 'white';
            return isSquareAttacked(kingPos.row, kingPos.col, opponentColor, currentBoard);
        }

        function simulateMove(fromRow, fromCol, toRow, toCol) {
            const tempBoard = board.map(row => row.map(p => p ? { ...p } : null)); // Deep copy
            const piece = tempBoard[fromRow][fromCol];

            if (piece) {
                 // Simulate En Passant capture for check testing
                 if (piece.type === 'pawn' && enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col) {
                    const capturedPawnRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                    tempBoard[capturedPawnRow][toCol] = null;
                 }

                tempBoard[toRow][toCol] = piece;
                tempBoard[fromRow][fromCol] = null;

                // Simulate castling rook move if needed for accurate check detection
                 if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
                     const rookCol = toCol > fromCol ? 7 : 0;
                     const rookTargetCol = toCol > fromCol ? 5 : 3;
                     if (tempBoard[fromRow][rookCol]) { // Ensure rook exists
                         tempBoard[fromRow][rookTargetCol] = tempBoard[fromRow][rookCol];
                         tempBoard[fromRow][rookCol] = null;
                     }
                 }
            }
            return tempBoard;
        }

        function hasAnyValidMoves(color) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === color) {
                        const moves = calculateValidMoves(piece, r, c);
                        // Filter moves that would leave the king in check
                        const legalMoves = moves.filter(move => {
                            const tempBoard = simulateMove(r, c, move.row, move.col);
                            return !isKingInCheck(color, tempBoard);
                        });
                        if (legalMoves.length > 0) {
                            return true; // Found at least one valid move
                        }
                    }
                }
            }
            return false; // No valid moves found for any piece
        }

        function updateCheckStatus() {
            checkStatus.white = isKingInCheck('white', board);
            checkStatus.black = isKingInCheck('black', board);
        }

        function checkGameEnd() {
            updateCheckStatus(); // Ensure check status is current

            if (!hasAnyValidMoves(currentPlayer)) {
                if (checkStatus[currentPlayer]) {
                    gameOver = `Checkmate! ${currentPlayer === 'white' ? 'Black' : 'White'} wins.`;
                } else {
                    gameOver = "Stalemate! It's a draw.";
                }
                return true; // Game has ended
            }
            gameOver = false;
            return false; // Game continues
        }

        // --- Reset ---
        resetButton.addEventListener('click', initGame);

        // --- Start Game ---
        initGame();

    </script>
</body>
</html>