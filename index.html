<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Chess Game</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #chessboard {
            width: 480px; /* 8 squares * 60px */
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 5px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .square { /* Back to being a div */
            width: 60px;
            height: 60px;
            display: flex; /* Keep flex for centering piece button */
            align-items: center;
            justify-content: center;
            position: relative; /* For valid move indicators */
            /* Remove button-specific styles */
            /* border: none; */
            /* padding: 0; */
            /* margin: 0; */
            /* cursor: pointer; */
            /* background: none; */
            /* transition: transform 0.1s ease-in-out; */
        }
        /* Remove hover effect from square div */
        /* .square:hover { ... } */


        .square.light { background-color: #f0d9b5; }
        .square.dark { background-color: #b58863; }

        /* --- Styles for the Piece Button --- */
        .piece-button {
            width: 100%;
            height: 100%;
            background: none;
            border: none;
            padding: 0;
            margin: 0;
            font-size: 40px; /* Piece size */
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Make button transparent to underlying square color */
            color: inherit; /* Inherit text color (set below) */
            text-shadow: inherit; /* Inherit text shadow (set below) */
            transition: transform 0.1s ease-in-out;
        }
        .piece-button:hover {
             transform: scale(1.1);
        }

        /* Apply piece colors and shadow to the button */
        .piece-button.white { color: #ffffff; text-shadow: 1px 1px 2px #000000; }
        .piece-button.black { color: #000000; text-shadow: 1px 1px 2px #aaaaaa;}

        /* Style for non-clickable opponent pieces */
        .piece-button.unclickable {
            pointer-events: none; /* Disable clicks and hover */
            opacity: 0.6; /* Visually indicate inactivity */
        }

        /* --- Selection and Indicators --- */

        /* Selected style applies to the BUTTON now */
        .piece-button.selected {
            /* Subtle background on the button itself */
            background-color: rgba(0, 255, 0, 0.2);
             /* Or maybe just an outline */
            /* outline: 2px solid rgba(0, 255, 0, 0.5); */
            /* outline-offset: -2px; */
            box-shadow: inset 0 0 3px 1px rgba(0, 100, 0, 0.5);
        }

        /* Indicators are children of the SQUARE div */
        .valid-move-indicator {
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            pointer-events: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
             z-index: 1; /* Ensure it's above the piece button if needed */
        }

        .capture-move-indicator {
             position: absolute;
             width: 90%;
             height: 90%;
             border: 3px dashed rgba(255, 0, 0, 0.5);
             border-radius: 5px;
             box-sizing: border-box;
             pointer-events: none;
             top: 5%;
             left: 5%;
             z-index: 1; /* Ensure it's above the piece button if needed */
        }

        #status {
            margin-top: 20px;
            font-size: 1.2em;
            font-weight: bold;
            min-height: 1.5em;
            color: #333;
        }

        #resetButton {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
         #resetButton:hover {
             background-color: #45a049;
         }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="status">White's turn</div>
        <div id="chessboard"></div>
        <button id="resetButton">Reset Game</button>
    </div>

    <script>
        const chessboardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');

        // --- Game State ---
        let board = []; // 8x8 array representing the board state
        let currentPlayer = 'white';
        let selectedPiece = null; // { element, piece, row, col }
        let validMoves = []; // Array of { row, col }
        let gameOver = false;
        let checkStatus = { white: false, black: false };
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let enPassantTarget = null; // { row, col } - The square *behind* a pawn that just moved two steps

        // --- Piece Representation ---
        const PIECES = {
            'P': { type: 'pawn', color: 'white', unicode: '♙' },
            'R': { type: 'rook', color: 'white', unicode: '♖' },
            'N': { type: 'knight', color: 'white', unicode: '♘' },
            'B': { type: 'bishop', color: 'white', unicode: '♗' },
            'Q': { type: 'queen', color: 'white', unicode: '♕' },
            'K': { type: 'king', color: 'white', unicode: '♔' },
            'p': { type: 'pawn', color: 'black', unicode: '♟' },
            'r': { type: 'rook', color: 'black', unicode: '♜' },
            'n': { type: 'knight', color: 'black', unicode: '♞' },
            'b': { type: 'bishop', color: 'black', unicode: '♝' },
            'q': { type: 'queen', color: 'black', unicode: '♛' },
            'k': { type: 'king', color: 'black', unicode: '♚' }
        };

        const initialBoardSetup = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // --- Initialization ---
        function initGame() {
            board = initialBoardSetup.map(row => row.map(p => p ? { ...PIECES[p] } : null));
            currentPlayer = 'white';
            selectedPiece = null;
            validMoves = [];
            gameOver = false;
            checkStatus = { white: false, black: false };
            castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            enPassantTarget = null;
            renderBoard();
            updateStatusDisplay();
        }

        // --- Rendering ---
        function renderBoard() {
            chessboardElement.innerHTML = ''; // Clear previous state

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const squareDiv = document.createElement('div'); // Create div for the square
                    squareDiv.classList.add('square');
                    squareDiv.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    squareDiv.dataset.row = r; // Store row/col on the div
                    squareDiv.dataset.col = c;

                    const piece = board[r][c];
                    if (piece) {
                        const pieceButton = document.createElement('button'); // Create button for the piece
                        pieceButton.classList.add('piece-button');
                        pieceButton.classList.add(piece.color); // 'white' or 'black' for styling
                        pieceButton.textContent = piece.unicode;
                        // Add data attributes to the button as well for easier event handling
                        pieceButton.dataset.type = piece.type;
                        pieceButton.dataset.color = piece.color;
                        // Note: row/col are on the parent div

                        // Add unclickable class if it's not the current player's piece
                        if (piece.color !== currentPlayer) {
                            pieceButton.classList.add('unclickable');
                        }

                        squareDiv.appendChild(pieceButton); // Add button to the square div
                    } else {
                        // Empty square - no button needed
                    }

                    chessboardElement.appendChild(squareDiv);
                }
            }
            // Re-attach event listener after rendering
            chessboardElement.removeEventListener('click', handleSquareClick); // Prevent duplicates
            chessboardElement.addEventListener('click', handleSquareClick);
        }

        // --- Event Handling ---
        function handleSquareClick(event) {
            if (gameOver) return;

            const target = event.target;
            let squareDiv, row, col, clickedPieceData = null, pieceButton = null, clickedPieceButton = null; // Declared pieceButton here

            // Determine what was clicked (piece button or square div)
            if (target.classList.contains('piece-button')) {
                pieceButton = target;
                squareDiv = target.closest('div.square'); // Get parent square
                if (!squareDiv) return; // Should not happen if HTML is correct
                clickedPieceData = board[squareDiv.dataset.row][squareDiv.dataset.col]; // Get data from board state
                clickedPieceButton = pieceButton; // Keep track of the button clicked
            } else if (target.classList.contains('square')) {
                squareDiv = target;
                // Clicked on an empty square div (or the div area around a piece button)
                clickedPieceData = board[squareDiv.dataset.row][squareDiv.dataset.col]; // Might be null
            } else if (target.closest('div.square')) {
                // Handle clicks on indicators or other elements inside a square div
                squareDiv = target.closest('div.square');
                clickedPieceData = board[squareDiv.dataset.row][squareDiv.dataset.col];
            }
             else {
                return; // Clicked outside a relevant element
            }

            row = parseInt(squareDiv.dataset.row);
            col = parseInt(squareDiv.dataset.col);

            if (selectedPiece) {
                // Attempting to make a move to the clicked square (div)
                const isValidTarget = validMoves.some(move => move.row === row && move.col === col);

                if (isValidTarget) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    clearSelectionAndHighlights();
                    switchPlayer();
                    updateCheckStatus();
                    checkGameEnd();
                    updateStatusDisplay();
                } else {
                    // Clicked somewhere else - deselect or select another piece
                    clearSelectionAndHighlights();
                    // If clicked on a piece button of the current player, select it
                    if (clickedPieceButton && clickedPieceData && clickedPieceData.color === currentPlayer) {
                        selectPiece(clickedPieceButton, clickedPieceData, row, col); // Pass button element
                    } else {
                        selectedPiece = null; // Just deselect if clicked empty square or opponent
                    }
                }
            } else {
                // No piece selected, try selecting one (only if a piece button was clicked)
                if (clickedPieceButton && clickedPieceData && clickedPieceData.color === currentPlayer) {
                    selectPiece(clickedPieceButton, clickedPieceData, row, col); // Pass button element
                }
            }
        }

        function selectPiece(pieceButton, pieceData, row, col) { // Takes pieceButton now
             // Deselect previous first (important if clicking another piece)
             clearSelectionAndHighlights();

             selectedPiece = { element: pieceButton, piece: pieceData, row, col }; // Store the button element
             validMoves = calculateValidMoves(pieceData, row, col);

             // Filter moves that would leave the king in check
             validMoves = validMoves.filter(move => {
                 const tempBoard = simulateMove(row, col, move.row, move.col);
                 return !isKingInCheck(currentPlayer, tempBoard);
             });

             highlightSelectedPiece(pieceButton); // Highlight the button
             highlightValidMoves(validMoves); // Highlight potential target squares (divs)
        }


        function clearSelectionAndHighlights() {
            if (selectedPiece && selectedPiece.element) {
                selectedPiece.element.classList.remove('selected'); // Remove from the piece button
            }
            // Keep selectedPiece object reference until the end
            const previouslySelected = selectedPiece;
            selectedPiece = null; // Clear selected piece *before* removing indicators

            // Remove all move indicators from square divs
            document.querySelectorAll('.valid-move-indicator, .capture-move-indicator').forEach(ind => ind.remove());

             // Reset valid moves *after* clearing highlights
             if (previouslySelected) {
                 validMoves = [];
             }
        }

        function highlightSelectedPiece(pieceButton) { // Takes pieceButton
            pieceButton.classList.add('selected'); // Apply 'selected' class to the button
        }

        function highlightValidMoves(moves) {
            moves.forEach(move => {
                // Select the target SQUARE DIV
                const targetSquareDiv = chessboardElement.querySelector(`div.square[data-row='${move.row}'][data-col='${move.col}']`);
                if (targetSquareDiv) {
                    const indicator = document.createElement('div');
                    const targetPiece = board[move.row][move.col];

                    // Check if the move is a capture (target square has a piece)
                    // Or if it's an en passant capture target
                    if (targetPiece !== null ||
                        (selectedPiece.piece.type === 'pawn' && move.col !== selectedPiece.col && targetPiece === null && enPassantTarget && move.row === enPassantTarget.row && move.col === enPassantTarget.col )) {
                        indicator.classList.add('capture-move-indicator');
                    } else {
                        indicator.classList.add('valid-move-indicator');
                    }
                    targetSquareDiv.appendChild(indicator); // Append indicator to the SQUARE DIV
                }
            });
        }

        // --- Move Logic ---
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const pieceToMove = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol]; // Could be null
            let specialMove = null; // 'enpassant', 'castling', 'promotion'

            // --- Handle Special Moves ---

            // En Passant Capture
            if (pieceToMove.type === 'pawn' &&
                enPassantTarget &&
                toRow === enPassantTarget.row &&
                toCol === enPassantTarget.col)
            {
                const capturedPawnRow = currentPlayer === 'white' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = null; // Remove the captured pawn
                specialMove = 'enpassant';
            }

            // Castling
            if (pieceToMove.type === 'king') {
                const colDiff = toCol - fromCol;
                if (Math.abs(colDiff) === 2) {
                    specialMove = 'castling';
                    const rookCol = colDiff > 0 ? 7 : 0; // King-side or Queen-side
                    const rookTargetCol = colDiff > 0 ? 5 : 3;
                    const rook = board[fromRow][rookCol];
                    board[fromRow][rookTargetCol] = rook; // Move rook
                    board[fromRow][rookCol] = null;
                }
            }

            // --- Update Board State ---
            board[toRow][toCol] = pieceToMove;
            board[fromRow][fromCol] = null;

            // --- Update Game State ---

            // Reset en passant target for the next turn
            let nextEnPassantTarget = null;
            if (pieceToMove.type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                nextEnPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };
            }
            enPassantTarget = nextEnPassantTarget; // Set for the *next* player

            // Update Castling Rights
            if (pieceToMove.type === 'king') {
                castlingRights[pieceToMove.color].kingSide = false;
                castlingRights[pieceToMove.color].queenSide = false;
            } else if (pieceToMove.type === 'rook') {
                if (fromCol === 0) castlingRights[pieceToMove.color].queenSide = false;
                if (fromCol === 7) castlingRights[pieceToMove.color].kingSide = false;
            }
            // If a rook is captured, update opponent's castling rights
            if (capturedPiece && capturedPiece.type === 'rook') {
                 const capturedColor = capturedPiece.color;
                 if (toRow === (capturedColor === 'white' ? 7 : 0)) {
                     if (toCol === 0) castlingRights[capturedColor].queenSide = false;
                     if (toCol === 7) castlingRights[capturedColor].kingSide = false;
                 }
            }


            // Pawn Promotion (Auto-Queen)
            if (pieceToMove.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                const promotedPieceKey = pieceToMove.color === 'white' ? 'Q' : 'q';
                board[toRow][toCol] = { ...PIECES[promotedPieceKey] };
                specialMove = 'promotion';
            }

            // --- Re-render the board based on the new state ---
            renderBoard(); // Simple re-render for now
        }

        function switchPlayer() {
            currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
        }

        function updateStatusDisplay() {
            if (gameOver) {
                statusElement.textContent = gameOver;
                statusElement.style.color = 'red';
            } else {
                let statusText = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
                if (checkStatus[currentPlayer]) {
                    statusText += " (Check!)";
                    statusElement.style.color = 'orange';
                } else {
                     statusElement.style.color = '#333';
                }
                statusElement.textContent = statusText;
            }
        }

        // --- Update Button Clickability --- 
        function updateButtonClickability() {
            const squares = chessboardElement.querySelectorAll('div.square');
            squares.forEach(square => {
                const r = parseInt(square.dataset.row);
                const c = parseInt(square.dataset.col);
                const pieceData = board[r][c]; // Get data from the current board state
                const pieceButton = square.querySelector('.piece-button');

                if (pieceButton) { // Only act if there is a piece button in the square
                    if (pieceData && pieceData.color === currentPlayer) {
                        pieceButton.classList.remove('unclickable');
                    } else {
                        pieceButton.classList.add('unclickable');
                    }
                }
            });
        }

        // --- Rule Calculations ---

        function calculateValidMoves(piece, row, col) {
            const moves = [];
            const color = piece.color;
            const opponentColor = (color === 'white') ? 'black' : 'white';

            const addMove = (r, c) => {
                if (isValidSquare(r, c)) {
                    const targetPiece = board[r][c];
                    if (targetPiece === null) {
                        moves.push({ row: r, col: c });
                        return true; // Square was empty, can continue sliding if applicable
                    } else if (targetPiece.color === opponentColor) {
                        moves.push({ row: r, col: c });
                        return false; // Capture, cannot continue sliding
                    } else {
                        return false; // Blocked by own piece
                    }
                }
                return false; // Off board
            };

            const addPawnMove = (r, c) => {
                 if (isValidSquare(r, c) && board[r][c] === null) {
                     moves.push({ row: r, col: c });
                     return true;
                 }
                 return false;
            };

            const addPawnCapture = (r, c) => {
                if (isValidSquare(r, c)) {
                    const targetPiece = board[r][c];
                    // Regular capture
                    if (targetPiece && targetPiece.color === opponentColor) {
                        moves.push({ row: r, col: c });
                    }
                    // En passant capture
                    else if (enPassantTarget && r === enPassantTarget.row && c === enPassantTarget.col) {
                         moves.push({ row: r, col: c });
                    }
                }
            };

            switch (piece.type) {
                case 'pawn':
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;

                    // Forward 1
                    if (addPawnMove(row + direction, col)) {
                        // Forward 2 (only from start row)
                        if (row === startRow) {
                            addPawnMove(row + 2 * direction, col);
                        }
                    }
                    // Captures
                    addPawnCapture(row + direction, col - 1);
                    addPawnCapture(row + direction, col + 1);
                    break;

                case 'rook':
                case 'bishop':
                case 'queen':
                    const directions = {
                        'rook': [[-1, 0], [1, 0], [0, -1], [0, 1]],
                        'bishop': [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                        'queen': [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
                    };
                    const pieceDirs = directions[piece.type];

                    pieceDirs.forEach(([dr, dc]) => {
                        let r = row + dr;
                        let c = col + dc;
                        while (addMove(r, c)) {
                            r += dr;
                            c += dc;
                        }
                    });
                    break;

                case 'knight':
                    const knightMoves = [
                        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                        [1, -2], [1, 2], [2, -1], [2, 1]
                    ];
                    knightMoves.forEach(([dr, dc]) => {
                        addMove(row + dr, col + dc);
                    });
                    break;

                case 'king':
                    const kingMoves = [
                        [-1, -1], [-1, 0], [-1, 1], [0, -1],
                        [0, 1], [1, -1], [1, 0], [1, 1]
                    ];
                    kingMoves.forEach(([dr, dc]) => {
                        addMove(row + dr, col + dc);
                    });

                    // Castling Logic
                    if (!isKingInCheck(color, board)) { // Cannot castle out of check
                        // King-side
                        if (castlingRights[color].kingSide &&
                            board[row][col + 1] === null &&
                            board[row][col + 2] === null &&
                            board[row][col + 3] && board[row][col+3].type === 'rook')
                         {
                            // Check if squares king moves *through* are attacked
                            if (!isSquareAttacked(row, col + 1, opponentColor, board) &&
                                !isSquareAttacked(row, col + 2, opponentColor, board)) {
                                moves.push({ row: row, col: col + 2 });
                            }
                        }
                        // Queen-side
                        if (castlingRights[color].queenSide &&
                            board[row][col - 1] === null &&
                            board[row][col - 2] === null &&
                            board[row][col - 3] === null &&
                             board[row][col - 4] && board[row][col-4].type === 'rook')
                        {
                             // Check if squares king moves *through* are attacked
                             if (!isSquareAttacked(row, col - 1, opponentColor, board) &&
                                 !isSquareAttacked(row, col - 2, opponentColor, board)) {
                                moves.push({ row: row, col: col - 2 });
                             }
                        }
                    }
                    break;
            }

            return moves;
        }

        function isValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function findKing(color, currentBoard) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        return { row: r, col: c };
                    }
                }
            }
            return null; // Should not happen in a valid game
        }

        function isSquareAttacked(targetRow, targetCol, attackerColor, currentBoard) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.color === attackerColor) {
                        // Calculate raw moves (ignoring check constraints for this check)
                        const rawMoves = calculateRawAttacks(piece, r, c, currentBoard);
                        if (rawMoves.some(move => move.row === targetRow && move.col === targetCol)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Calculates potential attacks *without* considering if the move puts own king in check
        // Necessary for check detection and castling safety checks
        function calculateRawAttacks(piece, row, col, currentBoard) {
             const moves = [];
             const color = piece.color;
             const opponentColor = (color === 'white') ? 'black' : 'white';

             // Simplified addMove for attack calculation (only needs destination)
             const addAttack = (r, c) => {
                 if (isValidSquare(r, c)) {
                     moves.push({ row: r, col: c });
                     // Check if blocked for sliding pieces
                     return currentBoard[r][c] === null;
                 }
                 return false;
             };
              const addPawnAttack = (r, c) => {
                 if (isValidSquare(r, c)) {
                      moves.push({ row: r, col: c });
                 }
             };


             switch (piece.type) {
                 case 'pawn':
                     const direction = color === 'white' ? -1 : 1;
                     addPawnAttack(row + direction, col - 1);
                     addPawnAttack(row + direction, col + 1);
                     break;
                 case 'rook':
                 case 'bishop':
                 case 'queen':
                     const directions = {
                         'rook': [[-1, 0], [1, 0], [0, -1], [0, 1]],
                         'bishop': [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                         'queen': [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
                     };
                     const pieceDirs = directions[piece.type];
                     pieceDirs.forEach(([dr, dc]) => {
                         let r = row + dr;
                         let c = col + dc;
                         while (addAttack(r, c)) { // addAttack returns true if empty, allowing slide
                             r += dr;
                             c += dc;
                         }
                     });
                     break;
                 case 'knight':
                     const knightMoves = [
                         [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                         [1, -2], [1, 2], [2, -1], [2, 1]
                     ];
                     knightMoves.forEach(([dr, dc]) => addAttack(row + dr, col + dc));
                     break;
                 case 'king':
                     const kingMoves = [
                         [-1, -1], [-1, 0], [-1, 1], [0, -1],
                         [0, 1], [1, -1], [1, 0], [1, 1]
                     ];
                     kingMoves.forEach(([dr, dc]) => addAttack(row + dr, col + dc));
                     break;
             }
             return moves;
        }


        function isKingInCheck(kingColor, currentBoard) {
            const kingPos = findKing(kingColor, currentBoard);
            if (!kingPos) return false; // King not found (shouldn't happen)
            const opponentColor = (kingColor === 'white') ? 'black' : 'white';
            return isSquareAttacked(kingPos.row, kingPos.col, opponentColor, currentBoard);
        }

        // Creates a deep copy of the board and simulates a move
        function simulateMove(fromRow, fromCol, toRow, toCol) {
            const tempBoard = board.map(row => row.map(p => p ? { ...p } : null)); // Deep copy
            const piece = tempBoard[fromRow][fromCol];

            // Basic move simulation (doesn't need full special move logic like en passant capture removal here)
            if (piece) {
                tempBoard[toRow][toCol] = piece;
                tempBoard[fromRow][fromCol] = null;

                // Simulate castling rook move if needed for accurate check detection
                 if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
                     const rookCol = toCol > fromCol ? 7 : 0;
                     const rookTargetCol = toCol > fromCol ? 5 : 3;
                     if (tempBoard[fromRow][rookCol]) { // Ensure rook exists
                         tempBoard[fromRow][rookTargetCol] = tempBoard[fromRow][rookCol];
                         tempBoard[fromRow][rookCol] = null;
                     }
                 }
            }
            return tempBoard;
        }

        function hasAnyValidMoves(color) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === color) {
                        const moves = calculateValidMoves(piece, r, c);
                        // Filter moves that would leave the king in check
                        const legalMoves = moves.filter(move => {
                            const tempBoard = simulateMove(r, c, move.row, move.col);
                            return !isKingInCheck(color, tempBoard);
                        });
                        if (legalMoves.length > 0) {
                            return true; // Found at least one valid move
                        }
                    }
                }
            }
            return false; // No valid moves found for any piece
        }

        function updateCheckStatus() {
            checkStatus.white = isKingInCheck('white', board);
            checkStatus.black = isKingInCheck('black', board);
        }

        function checkGameEnd() {
            updateCheckStatus(); // Ensure check status is current

            if (!hasAnyValidMoves(currentPlayer)) {
                if (checkStatus[currentPlayer]) {
                    gameOver = `Checkmate! ${currentPlayer === 'white' ? 'Black' : 'White'} wins.`;
                } else {
                    gameOver = "Stalemate! It's a draw.";
                }
                return true; // Game has ended
            }
            // Add other draw conditions here if needed (insufficient material, etc.)
            gameOver = false;
            return false; // Game continues
        }

        // --- Reset ---
        resetButton.addEventListener('click', initGame);

        // --- Start Game ---
        initGame();

    </script>
</body>
</html>