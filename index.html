<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTML Chess Game</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            background-color: #f0f0f0;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #chessboard {
            width: 480px; /* 8 squares * 60px */
            height: 480px;
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: 5px solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .square {
            width: 60px;
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative; /* For valid move indicators */
        }

        .square.light { background-color: #f0d9b5; }
        .square.dark { background-color: #b58863; }

        .piece-button {
            width: 90%;
            height: 90%;
            background: none;
            border: none;
            font-size: 40px; /* Adjust size as needed */
            cursor: pointer;
            padding: 0;
            margin: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s ease-in-out;
            border-radius: 5px; /* Slightly rounded corners */
        }

        .piece-button:hover {
             transform: scale(1.05);
        }

        .piece-button.white { color: #ffffff; text-shadow: 1px 1px 2px #000000; }
        .piece-button.black { color: #000000; text-shadow: 1px 1px 2px #aaaaaa;}

        .selected {
            background-color: rgba(0, 255, 0, 0.3); /* Greenish highlight */
            box-shadow: inset 0 0 5px 2px rgba(0, 100, 0, 0.7);
        }

        .valid-move-indicator {
            position: absolute;
            width: 25%;
            height: 25%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 50%;
            pointer-events: none; /* Allow clicks to pass through to the square */
        }

        .capture-move-indicator {
             position: absolute;
             width: 90%;
             height: 90%;
             border: 3px dashed rgba(255, 0, 0, 0.5);
             border-radius: 5px;
             box-sizing: border-box;
             pointer-events: none;
        }


        #status {
            margin-top: 20px;
            font-size: 1.2em;
            font-weight: bold;
            min-height: 1.5em;
            color: #333;
        }

        #resetButton {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 1em;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
        }
         #resetButton:hover {
             background-color: #45a049;
         }

    </style>
</head>
<body>
    <div id="game-container">
        <div id="status">White's turn</div>
        <div id="chessboard"></div>
        <button id="resetButton">Reset Game</button>
    </div>

    <script>
        const chessboardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const resetButton = document.getElementById('resetButton');

        // --- Game State ---
        let board = []; // 8x8 array representing the board state
        let currentPlayer = 'white';
        let selectedPiece = null; // { element, piece, row, col }
        let validMoves = []; // Array of { row, col }
        let gameOver = false;
        let checkStatus = { white: false, black: false };
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let enPassantTarget = null; // { row, col } - The square *behind* a pawn that just moved two steps

        // --- Piece Representation ---
        const PIECES = {
            'P': { type: 'pawn', color: 'white', unicode: '♙' },
            'R': { type: 'rook', color: 'white', unicode: '♖' },
            'N': { type: 'knight', color: 'white', unicode: '♘' },
            'B': { type: 'bishop', color: 'white', unicode: '♗' },
            'Q': { type: 'queen', color: 'white', unicode: '♕' },
            'K': { type: 'king', color: 'white', unicode: '♔' },
            'p': { type: 'pawn', color: 'black', unicode: '♟' },
            'r': { type: 'rook', color: 'black', unicode: '♜' },
            'n': { type: 'knight', color: 'black', unicode: '♞' },
            'b': { type: 'bishop', color: 'black', unicode: '♝' },
            'q': { type: 'queen', color: 'black', unicode: '♛' },
            'k': { type: 'king', color: 'black', unicode: '♚' }
        };

        const initialBoardSetup = [
            ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
            ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            [null, null, null, null, null, null, null, null],
            ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
            ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
        ];

        // --- Initialization ---
        function initGame() {
            board = initialBoardSetup.map(row => row.map(p => p ? { ...PIECES[p] } : null));
            currentPlayer = 'white';
            selectedPiece = null;
            validMoves = [];
            gameOver = false;
            checkStatus = { white: false, black: false };
            castlingRights = {
                white: { kingSide: true, queenSide: true },
                black: { kingSide: true, queenSide: true }
            };
            enPassantTarget = null;
            renderBoard();
            updateStatusDisplay();
        }

        // --- Rendering ---
        function renderBoard() {
            chessboardElement.innerHTML = ''; // Clear previous state

            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const square = document.createElement('div');
                    square.classList.add('square');
                    square.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    square.dataset.row = r;
                    square.dataset.col = c;

                    const piece = board[r][c];
                    if (piece) {
                        const pieceButton = document.createElement('button');
                        pieceButton.classList.add('piece-button');
                        pieceButton.classList.add(piece.color);
                        pieceButton.textContent = piece.unicode;
                        pieceButton.dataset.type = piece.type;
                        pieceButton.dataset.color = piece.color;
                        square.appendChild(pieceButton);
                    }

                    chessboardElement.appendChild(square);
                }
            }
            // Re-attach event listener after rendering
            chessboardElement.removeEventListener('click', handleSquareClick); // Prevent duplicates
            chessboardElement.addEventListener('click', handleSquareClick);
        }

        // --- Event Handling ---
        function handleSquareClick(event) {
            if (gameOver) return;

            const target = event.target;
            // Find the parent square element, whether clicking the square or the button inside
            const squareElement = target.closest('.square');
            if (!squareElement) return; // Clicked outside a square

            const row = parseInt(squareElement.dataset.row);
            const col = parseInt(squareElement.dataset.col);
            const clickedPieceData = board[row][col];

            if (selectedPiece) {
                // Attempting to make a move
                const isValidTarget = validMoves.some(move => move.row === row && move.col === col);

                if (isValidTarget) {
                    makeMove(selectedPiece.row, selectedPiece.col, row, col);
                    clearSelectionAndHighlights();
                    switchPlayer();
                    // Check for game end conditions *after* switching player
                    updateCheckStatus();
                    checkGameEnd();
                    updateStatusDisplay();
                } else {
                    // Clicked somewhere else - deselect or select another piece
                    clearSelectionAndHighlights();
                    // If clicked on another piece of the current player, select it
                    if (clickedPieceData && clickedPieceData.color === currentPlayer) {
                        selectPiece(squareElement, clickedPieceData, row, col);
                    } else {
                        selectedPiece = null; // Just deselect
                    }
                }
            } else {
                // No piece selected, try selecting one
                if (clickedPieceData && clickedPieceData.color === currentPlayer) {
                    selectPiece(squareElement, clickedPieceData, row, col);
                }
            }
        }

        function selectPiece(squareElement, pieceData, row, col) {
             const pieceButton = squareElement.querySelector('.piece-button');
             if (!pieceButton) return; // Should not happen if pieceData exists

             selectedPiece = { element: pieceButton, piece: pieceData, row, col };
             validMoves = calculateValidMoves(pieceData, row, col);

             // Filter moves that would leave the king in check
             validMoves = validMoves.filter(move => {
                 const tempBoard = simulateMove(row, col, move.row, move.col);
                 return !isKingInCheck(currentPlayer, tempBoard);
             });

             highlightSelectedPiece(pieceButton);
             highlightValidMoves(validMoves);
        }


        function clearSelectionAndHighlights() {
            if (selectedPiece && selectedPiece.element) {
                selectedPiece.element.classList.remove('selected');
            }
            selectedPiece = null;
            validMoves = [];
            // Remove all move indicators
            document.querySelectorAll('.valid-move-indicator, .capture-move-indicator').forEach(ind => ind.remove());
        }

        function highlightSelectedPiece(pieceButton) {
            pieceButton.classList.add('selected');
        }

        function highlightValidMoves(moves) {
            moves.forEach(move => {
                const targetSquare = chessboardElement.querySelector(`.square[data-row='${move.row}'][data-col='${move.col}']`);
                if (targetSquare) {
                    const indicator = document.createElement('div');
                    // Check if the move is a capture
                    if (board[move.row][move.col] !== null ||
                        (selectedPiece.piece.type === 'pawn' && move.col !== selectedPiece.col && board[move.row][move.col] === null)) { // En passant capture
                        indicator.classList.add('capture-move-indicator');
                    } else {
                        indicator.classList.add('valid-move-indicator');
                    }
                    targetSquare.appendChild(indicator);
                }
            });
        }

        // --- Move Logic ---
        function makeMove(fromRow, fromCol, toRow, toCol) {
            const pieceToMove = board[fromRow][fromCol];
            const capturedPiece = board[toRow][toCol]; // Could be null
            let specialMove = null; // 'enpassant', 'castling', 'promotion'

            // --- Handle Special Moves ---

            // En Passant Capture
            if (pieceToMove.type === 'pawn' &&
                enPassantTarget &&
                toRow === enPassantTarget.row &&
                toCol === enPassantTarget.col)
            {
                const capturedPawnRow = currentPlayer === 'white' ? toRow + 1 : toRow - 1;
                board[capturedPawnRow][toCol] = null; // Remove the captured pawn
                specialMove = 'enpassant';
            }

            // Castling
            if (pieceToMove.type === 'king') {
                const colDiff = toCol - fromCol;
                if (Math.abs(colDiff) === 2) {
                    specialMove = 'castling';
                    const rookCol = colDiff > 0 ? 7 : 0; // King-side or Queen-side
                    const rookTargetCol = colDiff > 0 ? 5 : 3;
                    const rook = board[fromRow][rookCol];
                    board[fromRow][rookTargetCol] = rook; // Move rook
                    board[fromRow][rookCol] = null;
                }
            }

            // --- Update Board State ---
            board[toRow][toCol] = pieceToMove;
            board[fromRow][fromCol] = null;

            // --- Update Game State ---

            // Reset en passant target for the next turn
            let nextEnPassantTarget = null;
            if (pieceToMove.type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                nextEnPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };
            }
            enPassantTarget = nextEnPassantTarget; // Set for the *next* player

            // Update Castling Rights
            if (pieceToMove.type === 'king') {
                castlingRights[pieceToMove.color].kingSide = false;
                castlingRights[pieceToMove.color].queenSide = false;
            } else if (pieceToMove.type === 'rook') {
                if (fromCol === 0) castlingRights[pieceToMove.color].queenSide = false;
                if (fromCol === 7) castlingRights[pieceToMove.color].kingSide = false;
            }
            // If a rook is captured, update opponent's castling rights
            if (capturedPiece && capturedPiece.type === 'rook') {
                 const capturedColor = capturedPiece.color;
                 if (toRow === (capturedColor === 'white' ? 7 : 0)) {
                     if (toCol === 0) castlingRights[capturedColor].queenSide = false;
                     if (toCol === 7) castlingRights[capturedColor].kingSide = false;
                 }
            }


            // Pawn Promotion (Auto-Queen)
            if (pieceToMove.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                const promotedPieceKey = pieceToMove.color === 'white' ? 'Q' : 'q';
                board[toRow][toCol] = { ...PIECES[promotedPieceKey] };
                specialMove = 'promotion';
            }

            // --- Re-render the board based on the new state ---
            renderBoard(); // Simple re-render for now
        }

        function switchPlayer() {
            currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
        }

        function updateStatusDisplay() {
            if (gameOver) {
                statusElement.textContent = gameOver;
                statusElement.style.color = 'red';
            } else {
                let statusText = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
                if (checkStatus[currentPlayer]) {
                    statusText += " (Check!)";
                    statusElement.style.color = 'orange';
                } else {
                     statusElement.style.color = '#333';
                }
                statusElement.textContent = statusText;
            }
        }

        // --- Rule Calculations ---

        function calculateValidMoves(piece, row, col) {
            const moves = [];
            const color = piece.color;
            const opponentColor = (color === 'white') ? 'black' : 'white';

            const addMove = (r, c) => {
                if (isValidSquare(r, c)) {
                    const targetPiece = board[r][c];
                    if (targetPiece === null) {
                        moves.push({ row: r, col: c });
                        return true; // Square was empty, can continue sliding if applicable
                    } else if (targetPiece.color === opponentColor) {
                        moves.push({ row: r, col: c });
                        return false; // Capture, cannot continue sliding
                    } else {
                        return false; // Blocked by own piece
                    }
                }
                return false; // Off board
            };

            const addPawnMove = (r, c) => {
                 if (isValidSquare(r, c) && board[r][c] === null) {
                     moves.push({ row: r, col: c });
                     return true;
                 }
                 return false;
            };

            const addPawnCapture = (r, c) => {
                if (isValidSquare(r, c)) {
                    const targetPiece = board[r][c];
                    // Regular capture
                    if (targetPiece && targetPiece.color === opponentColor) {
                        moves.push({ row: r, col: c });
                    }
                    // En passant capture
                    else if (enPassantTarget && r === enPassantTarget.row && c === enPassantTarget.col) {
                         moves.push({ row: r, col: c });
                    }
                }
            };

            switch (piece.type) {
                case 'pawn':
                    const direction = color === 'white' ? -1 : 1;
                    const startRow = color === 'white' ? 6 : 1;

                    // Forward 1
                    if (addPawnMove(row + direction, col)) {
                        // Forward 2 (only from start row)
                        if (row === startRow) {
                            addPawnMove(row + 2 * direction, col);
                        }
                    }
                    // Captures
                    addPawnCapture(row + direction, col - 1);
                    addPawnCapture(row + direction, col + 1);
                    break;

                case 'rook':
                case 'bishop':
                case 'queen':
                    const directions = {
                        'rook': [[-1, 0], [1, 0], [0, -1], [0, 1]],
                        'bishop': [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                        'queen': [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
                    };
                    const pieceDirs = directions[piece.type];

                    pieceDirs.forEach(([dr, dc]) => {
                        let r = row + dr;
                        let c = col + dc;
                        while (addMove(r, c)) {
                            r += dr;
                            c += dc;
                        }
                    });
                    break;

                case 'knight':
                    const knightMoves = [
                        [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                        [1, -2], [1, 2], [2, -1], [2, 1]
                    ];
                    knightMoves.forEach(([dr, dc]) => {
                        addMove(row + dr, col + dc);
                    });
                    break;

                case 'king':
                    const kingMoves = [
                        [-1, -1], [-1, 0], [-1, 1], [0, -1],
                        [0, 1], [1, -1], [1, 0], [1, 1]
                    ];
                    kingMoves.forEach(([dr, dc]) => {
                        addMove(row + dr, col + dc);
                    });

                    // Castling Logic
                    if (!isKingInCheck(color, board)) { // Cannot castle out of check
                        // King-side
                        if (castlingRights[color].kingSide &&
                            board[row][col + 1] === null &&
                            board[row][col + 2] === null &&
                            board[row][col + 3] && board[row][col+3].type === 'rook')
                         {
                            // Check if squares king moves *through* are attacked
                            if (!isSquareAttacked(row, col + 1, opponentColor, board) &&
                                !isSquareAttacked(row, col + 2, opponentColor, board)) {
                                moves.push({ row: row, col: col + 2 });
                            }
                        }
                        // Queen-side
                        if (castlingRights[color].queenSide &&
                            board[row][col - 1] === null &&
                            board[row][col - 2] === null &&
                            board[row][col - 3] === null &&
                             board[row][col - 4] && board[row][col-4].type === 'rook')
                        {
                             // Check if squares king moves *through* are attacked
                             if (!isSquareAttacked(row, col - 1, opponentColor, board) &&
                                 !isSquareAttacked(row, col - 2, opponentColor, board)) {
                                moves.push({ row: row, col: col - 2 });
                             }
                        }
                    }
                    break;
            }

            return moves;
        }

        function isValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function findKing(color, currentBoard) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.type === 'king' && piece.color === color) {
                        return { row: r, col: c };
                    }
                }
            }
            return null; // Should not happen in a valid game
        }

        function isSquareAttacked(targetRow, targetCol, attackerColor, currentBoard) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r][c];
                    if (piece && piece.color === attackerColor) {
                        // Calculate raw moves (ignoring check constraints for this check)
                        const rawMoves = calculateRawAttacks(piece, r, c, currentBoard);
                        if (rawMoves.some(move => move.row === targetRow && move.col === targetCol)) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Calculates potential attacks *without* considering if the move puts own king in check
        // Necessary for check detection and castling safety checks
        function calculateRawAttacks(piece, row, col, currentBoard) {
             const moves = [];
             const color = piece.color;
             const opponentColor = (color === 'white') ? 'black' : 'white';

             // Simplified addMove for attack calculation (only needs destination)
             const addAttack = (r, c) => {
                 if (isValidSquare(r, c)) {
                     moves.push({ row: r, col: c });
                     // Check if blocked for sliding pieces
                     return currentBoard[r][c] === null;
                 }
                 return false;
             };
              const addPawnAttack = (r, c) => {
                 if (isValidSquare(r, c)) {
                      moves.push({ row: r, col: c });
                 }
             };


             switch (piece.type) {
                 case 'pawn':
                     const direction = color === 'white' ? -1 : 1;
                     addPawnAttack(row + direction, col - 1);
                     addPawnAttack(row + direction, col + 1);
                     break;
                 case 'rook':
                 case 'bishop':
                 case 'queen':
                     const directions = {
                         'rook': [[-1, 0], [1, 0], [0, -1], [0, 1]],
                         'bishop': [[-1, -1], [-1, 1], [1, -1], [1, 1]],
                         'queen': [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]]
                     };
                     const pieceDirs = directions[piece.type];
                     pieceDirs.forEach(([dr, dc]) => {
                         let r = row + dr;
                         let c = col + dc;
                         while (addAttack(r, c)) { // addAttack returns true if empty, allowing slide
                             r += dr;
                             c += dc;
                         }
                     });
                     break;
                 case 'knight':
                     const knightMoves = [
                         [-2, -1], [-2, 1], [-1, -2], [-1, 2],
                         [1, -2], [1, 2], [2, -1], [2, 1]
                     ];
                     knightMoves.forEach(([dr, dc]) => addAttack(row + dr, col + dc));
                     break;
                 case 'king':
                     const kingMoves = [
                         [-1, -1], [-1, 0], [-1, 1], [0, -1],
                         [0, 1], [1, -1], [1, 0], [1, 1]
                     ];
                     kingMoves.forEach(([dr, dc]) => addAttack(row + dr, col + dc));
                     break;
             }
             return moves;
        }


        function isKingInCheck(kingColor, currentBoard) {
            const kingPos = findKing(kingColor, currentBoard);
            if (!kingPos) return false; // King not found (shouldn't happen)
            const opponentColor = (kingColor === 'white') ? 'black' : 'white';
            return isSquareAttacked(kingPos.row, kingPos.col, opponentColor, currentBoard);
        }

        // Creates a deep copy of the board and simulates a move
        function simulateMove(fromRow, fromCol, toRow, toCol) {
            const tempBoard = board.map(row => row.map(p => p ? { ...p } : null)); // Deep copy
            const piece = tempBoard[fromRow][fromCol];

            // Basic move simulation (doesn't need full special move logic like en passant capture removal here)
            if (piece) {
                tempBoard[toRow][toCol] = piece;
                tempBoard[fromRow][fromCol] = null;

                // Simulate castling rook move if needed for accurate check detection
                 if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
                     const rookCol = toCol > fromCol ? 7 : 0;
                     const rookTargetCol = toCol > fromCol ? 5 : 3;
                     if (tempBoard[fromRow][rookCol]) { // Ensure rook exists
                         tempBoard[fromRow][rookTargetCol] = tempBoard[fromRow][rookCol];
                         tempBoard[fromRow][rookCol] = null;
                     }
                 }
            }
            return tempBoard;
        }

        function hasAnyValidMoves(color) {
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = board[r][c];
                    if (piece && piece.color === color) {
                        const moves = calculateValidMoves(piece, r, c);
                        // Filter moves that would leave the king in check
                        const legalMoves = moves.filter(move => {
                            const tempBoard = simulateMove(r, c, move.row, move.col);
                            return !isKingInCheck(color, tempBoard);
                        });
                        if (legalMoves.length > 0) {
                            return true; // Found at least one valid move
                        }
                    }
                }
            }
            return false; // No valid moves found for any piece
        }

        function updateCheckStatus() {
            checkStatus.white = isKingInCheck('white', board);
            checkStatus.black = isKingInCheck('black', board);
        }

        function checkGameEnd() {
            updateCheckStatus(); // Ensure check status is current

            if (!hasAnyValidMoves(currentPlayer)) {
                if (checkStatus[currentPlayer]) {
                    gameOver = `Checkmate! ${currentPlayer === 'white' ? 'Black' : 'White'} wins.`;
                } else {
                    gameOver = "Stalemate! It's a draw.";
                }
                return true; // Game has ended
            }
            // Add other draw conditions here if needed (insufficient material, etc.)
            gameOver = false;
            return false; // Game continues
        }

        // --- Reset ---
        resetButton.addEventListener('click', initGame);

        // --- Start Game ---
        initGame();

    </script>
</body>
</html>