<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Chess</title>
    <!-- Import Supabase Client Library -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            /* justify-content: center; */ /* Allow scrolling if needed */
            min-height: 100vh;
            background-color: #f0f0f0;
            margin: 10px 0; /* Add some margin */
            padding: 0;
        }

        .hidden { display: none !important; }

        #mode-selection, #friend-setup, #waiting-screen, #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            text-align: center;
            width: 90%;
            max-width: 550px; /* Limit width */
        }

        button, input[type="text"] {
            padding: 10px 15px; /* Slightly smaller padding */
            font-size: 0.95em; /* Slightly smaller font */
            margin: 5px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-radius: 5px;
        }
        button {
             background-color: #4CAF50;
             color: white;
             border: none;
             min-width: 100px; /* Ensure buttons have some width */
        }
         button:hover {
             background-color: #45a049;
         }
         button:disabled {
             background-color: #cccccc;
             cursor: not-allowed;
         }
         input[type="text"] {
             width: 80%; /* Relative width */
             max-width: 250px;
         }

        #share-link-area {
            margin-top: 15px;
            padding: 10px;
            background-color: #e9e9e9;
            border: 1px dashed #ccc;
            border-radius: 4px;
            word-break: break-all;
            width: 95%;
        }
         #share-link-area input {
             width: calc(100% - 110px); /* Adjust width based on button */
             margin-bottom: 5px;
             margin-right: 5px;
             box-sizing: border-box;
         }
         #share-link-area button {
             width: 100px; /* Fixed width for copy button */
             vertical-align: middle;
         }

        /* --- Chessboard and Piece Styling --- */
        #board-container {
            display: grid;
            grid-template-areas:
                ". top ."
                "left board right"
                ". bottom .";
            grid-template-columns: auto 1fr auto;
            grid-template-rows: auto 1fr auto;
            gap: 3px; /* Reduced gap */
            margin-top: 10px;
            /* Ensure container doesn't exceed viewport width */
            max-width: 100%;
        }

        /* Use viewport units for sizing to make it responsive */
        :root {
            --board-size: min(80vw, 440px); /* Adjust max size as needed */
            --square-size: calc(var(--board-size) / 8);
            --piece-size: calc(var(--square-size) * 0.7);
            --label-size: calc(var(--square-size) * 0.6);
            --border-width: max(2px, calc(var(--square-size) * 0.05)); /* Responsive border */
        }

        .labels { display: flex; justify-content: center; align-items: center; font-weight: bold; color: #555; font-size: calc(var(--label-size) * 0.8); }
        .labels.files { flex-direction: row; height: var(--label-size); }
        .labels.ranks { flex-direction: column; width: var(--label-size); }
        .label { width: var(--square-size); height: var(--square-size); display: flex; justify-content: center; align-items: center; box-sizing: border-box;}
        #top-files    { grid-area: top; }
        #bottom-files { grid-area: bottom; }
        #left-ranks   { grid-area: left; }
        #right-ranks  { grid-area: right; }

        #chessboard {
            grid-area: board;
            width: var(--board-size);
            height: var(--board-size);
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            border: var(--border-width) solid #333;
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }

        .square-base { width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; font-size: 1px; color: transparent; box-sizing: border-box; position: relative; border: none; padding: 0; margin: 0; }
        .square-base.has-piece::before { content: attr(data-piece-symbol); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: var(--piece-size); color: inherit; text-shadow: inherit; pointer-events: none; }
        .square-base.light { background-color: #f0d9b5; }
        .square-base.dark { background-color: #b58863; }
        .square-base.white { color: #ffffff; text-shadow: 1px 1px 2px #000000; }
        .square-base.black { color: #000000; text-shadow: 1px 1px 2px #aaaaaa;}
        .square-button { cursor: pointer; transition: background-color 0.1s ease-in-out, box-shadow 0.1s ease-in-out; }
        .square-button:hover { filter: brightness(1.1); }
        .square-button.selected { box-shadow: inset 0 0 0 var(--border-width) rgba(0, 150, 0, 0.8); }
        .square-button.valid-move::after { content: ''; position: absolute; width: 25%; height: 25%; background-color: rgba(0, 0, 0, 0.25); border-radius: 50%; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        /* Use outline for capture indicator for better composability with selection */
        .square-button.capture-move { outline: var(--border-width) dashed rgba(200, 0, 0, 0.7); outline-offset: calc(-1 * var(--border-width)); }
        .square-div { cursor: default; }


        #status {
            margin-top: 10px;
            font-size: 1.1em; /* Adjust size */
            font-weight: bold;
            min-height: 1.4em;
            color: #333;
        }
         #info-area {
             margin-top: 5px;
             font-size: 0.9em;
             color: #666;
             min-height: 1.2em;
         }

    </style>
</head>
<body>

    <h1>Web Chess</h1>

    <!-- 1. Mode Selection -->
    <div id="mode-selection">
        <h2>Choose Game Mode</h2>
        <button id="selfPlayButton">Self-play</button>
        <button id="friendPlayButton">Play with Friend</button>
    </div>

    <!-- 2. Friend Mode Setup -->
    <div id="friend-setup" class="hidden">
        <h2>Play with Friend</h2>
        <input type="text" id="player1NameInput" placeholder="Enter your name (Player 1 - White)">
        <button id="createGameButton">Create Game & Get Link</button>
        <button id="backToModeSelectionButton1">Back</button>
    </div>

    <!-- 3. Waiting Screen (Friend Mode) -->
    <div id="waiting-screen" class="hidden">
        <h2>Waiting for Friend...</h2>
        <p>Share this link with your friend:</p>
        <div id="share-link-area">
             <input type="text" id="shareLinkInput" readonly>
             <button id="copyLinkButton">Copy Link</button>
        </div>
         <p id="waiting-message"></p>
         <button id="cancelGameButton">Cancel Game</button>
    </div>

    <!-- 4. Game Area (Both Modes) -->
    <div id="game-area" class="hidden">
        <div id="status">White's turn</div>
        <div id="info-area"></div> <!-- For player names or messages -->
        <div id="board-container">
            <div id="top-files" class="labels files"></div>
            <div id="left-ranks" class="labels ranks"></div>
            <div id="chessboard"></div>
            <div id="right-ranks" class="labels ranks"></div>
            <div id="bottom-files" class="labels files"></div>
        </div>
        <button id="resetButton">Reset Game</button> <!-- Only works in Self-Play -->
    </div>

    <script>
        // --- DOM Elements ---
        const modeSelectionDiv = document.getElementById('mode-selection');
        const friendSetupDiv = document.getElementById('friend-setup');
        const waitingScreenDiv = document.getElementById('waiting-screen');
        const gameAreaDiv = document.getElementById('game-area');
        const selfPlayButton = document.getElementById('selfPlayButton');
        const friendPlayButton = document.getElementById('friendPlayButton');
        const player1NameInput = document.getElementById('player1NameInput');
        const createGameButton = document.getElementById('createGameButton');
        const backToModeSelectionButton1 = document.getElementById('backToModeSelectionButton1');
        const shareLinkInput = document.getElementById('shareLinkInput');
        const copyLinkButton = document.getElementById('copyLinkButton');
        const waitingMessage = document.getElementById('waiting-message');
        const cancelGameButton = document.getElementById('cancelGameButton');
        const chessboardElement = document.getElementById('chessboard');
        const statusElement = document.getElementById('status');
        const infoElement = document.getElementById('info-area');
        const resetButton = document.getElementById('resetButton');
        const topFilesLabel = document.getElementById('top-files');
        const bottomFilesLabel = document.getElementById('bottom-files');
        const leftRanksLabel = document.getElementById('left-ranks');
        const rightRanksLabel = document.getElementById('right-ranks');

        // --- Supabase Config ---
        // IMPORTANT: Replace with your actual Supabase URL and Anon Key
        const SUPABASE_URL = 'https://knjmvosajcdmfqffkzcb.supabase.co'; // Use your URL
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imtuam12b3NhamNkbWZxZmZremNiIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDUzMjg5NDgsImV4cCI6MjA2MDkwNDk0OH0.Ii6VAM9KiaG2urHinrUfFmSP_YBXA7l-O5l__Q9CPUI'; // Use your Anon Key

        // Initialize Supabase Client (Corrected)
        const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // --- Game Constants ---
        const PIECES = { 'P': { type: 'pawn', color: 'white', unicode: '♙' }, 'R': { type: 'rook', color: 'white', unicode: '♖' }, 'N': { type: 'knight', color: 'white', unicode: '♘' }, 'B': { type: 'bishop', color: 'white', unicode: '♗' }, 'Q': { type: 'queen', color: 'white', unicode: '♕' }, 'K': { type: 'king', color: 'white', unicode: '♔' }, 'p': { type: 'pawn', color: 'black', unicode: '♟' }, 'r': { type: 'rook', color: 'black', unicode: '♜' }, 'n': { type: 'knight', color: 'black', unicode: '♞' }, 'b': { type: 'bishop', color: 'black', unicode: '♝' }, 'q': { type: 'queen', color: 'black', unicode: '♛' }, 'k': { type: 'king', color: 'black', unicode: '♚' } };
        const initialBoardSimple = [ ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'], ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], [null, null, null, null, null, null, null, null], ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'], ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R'] ];
        const initialCastlingRights = { white: { kingSide: true, queenSide: true }, black: { kingSide: true, queenSide: true } };

        // --- Game State ---
        let gameMode = null; // 'self' or 'friend'
        let board = []; // The 8x8 board with piece objects or null
        let currentPlayer = 'white';
        let selectedPiece = null; // { piece, row, col }
        let validMoves = []; // Array of { row, col } for the selected piece
        let initialClickablePieces = []; // Array of {row, col} for pieces clickable at turn start
        let gameOver = false; // Or status string like "Checkmate! ..."
        let checkStatus = { white: false, black: false };
        let castlingRights = JSON.parse(JSON.stringify(initialCastlingRights)); // Deep copy
        let enPassantTarget = null; // { row, col } or null

        // --- Friend Mode State ---
        let currentGameId = null;
        let playerColor = null; // 'white' or 'black' (assigned in friend mode)
        let player1Name = '';
        let player2Name = '';
        let gameSubscription = null;
        let isMyTurn = false; // Derived from currentPlayer and playerColor

        // --- Initialization ---
        function initGame(initialState = null) {
            console.log("Initializing game. Mode:", gameMode, "Initial State:", initialState);

            if (gameMode === 'self' || !initialState) {
                // Self-play or initial setup for friend mode before data received
                board = deserializeBoard(initialBoardSimple);
                currentPlayer = 'white';
                castlingRights = JSON.parse(JSON.stringify(initialCastlingRights));
                enPassantTarget = null;
                gameOver = false;
                 player1Name = 'Player 1';
                 player2Name = 'Player 2';
                 playerColor = 'white'; // In self-play, you technically control both
                 isMyTurn = true; // Always allow moves in self-play start
                 infoElement.textContent = ''; // Clear names initially
            } else if (gameMode === 'friend' && initialState) {
                // Load state from Supabase for friend mode
                board = deserializeBoard(initialState.board_state);
                currentPlayer = initialState.current_turn;
                // Ensure castling rights are valid objects, default if null/malformed
                castlingRights = (initialState.castling_rights && typeof initialState.castling_rights === 'object')
                                  ? initialState.castling_rights
                                  : JSON.parse(JSON.stringify(initialCastlingRights));
                enPassantTarget = initialState.en_passant_target; // Supabase stores JSON directly
                player1Name = initialState.player_white_name || 'White';
                player2Name = initialState.player_black_name || 'Black';
                gameOver = determineGameOverStatus(initialState.game_status, initialState.winner);
                currentGameId = initialState.id; // Ensure game ID is set
            }

            selectedPiece = null;
            validMoves = [];
            initialClickablePieces = [];
            checkStatus = { white: false, black: false };

            // Disable reset button in friend mode (simplification)
            resetButton.disabled = (gameMode === 'friend');

            // Show/Hide UI
            modeSelectionDiv.classList.add('hidden');
            friendSetupDiv.classList.add('hidden');
            waitingScreenDiv.classList.add('hidden');
            gameAreaDiv.classList.remove('hidden');

            createLabels();
            prepareTurn(); // Calculate initial state, check game end, render
        }

        // --- UI Navigation ---
        function showModeSelection() {
            modeSelectionDiv.classList.remove('hidden');
            friendSetupDiv.classList.add('hidden');
            waitingScreenDiv.classList.add('hidden');
            gameAreaDiv.classList.add('hidden');
            cleanupSubscription(); // Ensure no lingering subscriptions
            resetLocalGameState(); // Reset variables if going back
        }

        function showFriendSetup() {
            modeSelectionDiv.classList.add('hidden');
            friendSetupDiv.classList.remove('hidden');
            waitingScreenDiv.classList.add('hidden');
            gameAreaDiv.classList.add('hidden');
        }

        function showWaitingScreen(gameId, p1Name) {
            modeSelectionDiv.classList.add('hidden');
            friendSetupDiv.classList.add('hidden');
            waitingScreenDiv.classList.remove('hidden');
            gameAreaDiv.classList.add('hidden');

            const link = `${window.location.origin}${window.location.pathname}#gameId=${gameId}`;
            shareLinkInput.value = link;
            waitingMessage.textContent = `Game created by ${p1Name}. Waiting for opponent...`;
            currentGameId = gameId; // Store the ID for cancellation
        }

        function resetLocalGameState() {
             gameMode = null;
             board = [];
             currentPlayer = 'white';
             selectedPiece = null;
             validMoves = [];
             initialClickablePieces = [];
             gameOver = false;
             checkStatus = { white: false, black: false };
             castlingRights = JSON.parse(JSON.stringify(initialCastlingRights));
             enPassantTarget = null;
             currentGameId = null;
             playerColor = null;
             player1Name = '';
             player2Name = '';
             gameSubscription = null;
             isMyTurn = false;
             statusElement.textContent = "White's turn";
             infoElement.textContent = "";
             chessboardElement.innerHTML = ''; // Clear board visually
        }

        // --- Board Representation Helpers ---
        function serializeBoard(boardWithObjs) {
            return boardWithObjs.map(row =>
                row.map(piece => {
                    if (!piece) return null;
                    return Object.keys(PIECES).find(key =>
                        PIECES[key].type === piece.type && PIECES[key].color === piece.color
                    ) || null;
                })
            );
        }

        function deserializeBoard(boardSimple) {
             if (!boardSimple || !Array.isArray(boardSimple)) {
                 console.error("Invalid simple board data for deserialization:", boardSimple);
                 return initialBoardSimple.map(row => row.map(p => p ? { ...PIECES[p] } : null));
             }
             return boardSimple.map(row =>
                 row.map(pieceKey => pieceKey ? { ...PIECES[pieceKey] } : null)
             );
        }

        // --- Supabase Interaction ---

        async function createSupabaseGame() {
            player1Name = player1NameInput.value.trim() || 'Player 1 (White)';
            if (!player1Name) {
                alert("Please enter your name.");
                return;
            }
            createGameButton.disabled = true;
            try {
                // Use supabaseClient (Corrected)
                const { data, error } = await supabaseClient
                    .from('chess_games')
                    .insert({
                        player_white_name: player1Name,
                        // Reset state to defaults on creation
                        board_state: initialBoardSimple,
                        current_turn: 'white',
                        castling_rights: initialCastlingRights,
                        en_passant_target: null,
                        game_status: 'waiting'
                    })
                    .select()
                    .single();

                if (error) throw error;

                if (data) {
                    console.log("Game created:", data);
                    gameMode = 'friend';
                    playerColor = 'white'; // Creator is White
                    currentGameId = data.id;
                    showWaitingScreen(data.id, player1Name);
                    startListeningForGameUpdates(data.id);
                } else {
                    alert("Failed to create game. No data returned.");
                    createGameButton.disabled = false;
                }
            } catch (error) {
                console.error("Error creating game:", error);
                alert(`Error creating game: ${error.message}`);
                createGameButton.disabled = false;
            }
        }

        async function joinSupabaseGame(gameId) {
            console.log("Attempting to join game:", gameId);
            try {
                 // Use supabaseClient (Corrected)
                 const { data: gameData, error: fetchError } = await supabaseClient
                     .from('chess_games')
                     .select('*')
                     .eq('id', gameId)
                     .single();

                 if (fetchError || !gameData) {
                     throw fetchError || new Error("Game not found.");
                 }

                 console.log("Found game:", gameData);

                 // Check game status
                 if (gameData.game_status !== 'waiting') {
                    if (gameData.game_status === 'active') {
                         // Rejoining logic
                         const name = prompt(`Game is active between ${gameData.player_white_name} and ${gameData.player_black_name}.\nEnter your name to rejoin:`);
                         if (name && name.trim() === gameData.player_white_name) playerColor = 'white';
                         else if (name && name.trim() === gameData.player_black_name) playerColor = 'black';
                         else { alert("Name doesn't match players. Cannot rejoin."); showModeSelection(); return; }

                         gameMode = 'friend';
                         currentGameId = gameId;
                         initGame(gameData); // Load the existing active game state
                         startListeningForGameUpdates(gameId);
                         return; // Skip the joining update logic
                    } else {
                         alert(`Cannot join game. Status: ${gameData.game_status}`);
                         showModeSelection();
                         return;
                     }
                 }

                 // Game is 'waiting', join as Black
                 player2Name = prompt(`Joining game created by ${gameData.player_white_name}.\nEnter your name (Player 2 - Black):`, "Player 2 (Black)");
                 if (!player2Name || !player2Name.trim()) {
                     alert("You must enter a name to join.");
                     return;
                 }
                 player2Name = player2Name.trim();

                 // Use supabaseClient (Corrected)
                 const { data: updateData, error: updateError } = await supabaseClient
                     .from('chess_games')
                     .update({
                         player_black_name: player2Name,
                         game_status: 'active'
                     })
                     .eq('id', gameId)
                     .select()
                     .single();

                 if (updateError) throw updateError;

                 console.log("Game joined and updated:", updateData);
                 gameMode = 'friend';
                 playerColor = 'black'; // Joiner is Black
                 currentGameId = gameId;
                 initGame(updateData); // Load the initial active game state
                 startListeningForGameUpdates(gameId);

            } catch (error) {
                 console.error("Error joining game:", error);
                 alert(`Error joining game: ${error.message}`);
                 showModeSelection();
            }
        }

         async function sendMoveToSupabase(fromRow, fromCol, toRow, toCol, promotionPiece = null) {
             if (gameMode !== 'friend' || !currentGameId || !isMyTurn) {
                 console.warn("Attempted to send move when not allowed.");
                 return;
             }

             console.log(`Sending move: ${getNotation(fromRow, fromCol)} to ${getNotation(toRow, toCol)}`);

             // Make the move locally first to update board, castling, en passant
             const moveResult = makeMove(fromRow, fromCol, toRow, toCol, promotionPiece);
             if (!moveResult) return; // Should not happen if validation passed

             // Get the updated state *after* makeMove
             const nextPlayer = (currentPlayer === 'white') ? 'black' : 'white';
             const simpleBoard = serializeBoard(board);
             const currentEnPassantTarget = enPassantTarget;
             const currentCastlingRights = castlingRights;

             // Check for game end state *after* the move is made locally
             updateCheckStatus(); // Update check status for the *next* player
             const nextPlayerClickablePieces = findClickablePiecesForPlayer(nextPlayer, board, currentCastlingRights, currentEnPassantTarget);
             let nextGameStatus = 'active';
             let winner = null;
             if (nextPlayerClickablePieces.length === 0) {
                 if (isKingInCheck(nextPlayer, board)) { // Checkmate
                     winner = currentPlayer; // The player who just moved wins
                     nextGameStatus = `checkmate_${winner}`;
                     gameOver = `Checkmate! ${winner === 'white' ? player1Name : player2Name} wins.`;
                 } else { // Stalemate
                     winner = 'draw';
                     nextGameStatus = 'stalemate';
                     gameOver = "Stalemate! It's a draw.";
                 }
                 console.log(`Game Over detected by sender: ${nextGameStatus}`);
             }

             // Update Supabase - Use supabaseClient (Corrected)
             try {
                 const { error } = await supabaseClient
                     .from('chess_games')
                     .update({
                         board_state: simpleBoard,
                         current_turn: nextPlayer,
                         en_passant_target: currentEnPassantTarget,
                         castling_rights: currentCastlingRights,
                         last_move_from: getNotation(fromRow, fromCol),
                         last_move_to: getNotation(toRow, toCol),
                         game_status: nextGameStatus, // Send calculated status
                         winner: winner // Send calculated winner
                     })
                     .eq('id', currentGameId);

                 if (error) throw error;

                 console.log("Move sent to Supabase successfully.");
                 // Local update will happen via subscription handler for consistency

             } catch (error) {
                 console.error("Error updating game state:", error);
                 alert(`Error sending move: ${error.message}. Game might be out of sync.`);
             }
         }

         // No need for sendGameEndStatusToSupabase - status sent with move

         async function cancelSupabaseGame() {
             if (!currentGameId) return;
             const confirmation = confirm("Are you sure you want to cancel this game? This cannot be undone.");
             if (!confirmation) return;

             cleanupSubscription(); // Stop listening first

             try {
                 // Use supabaseClient (Corrected)
                 const { error } = await supabaseClient
                     .from('chess_games')
                     .update({ game_status: 'aborted', winner: 'none' }) // Mark as aborted
                     .eq('id', currentGameId);

                 if (error) throw error;
                 console.log("Game cancelled/aborted in database.");
                 showModeSelection(); // Go back to start screen

             } catch (error) {
                 console.error("Error cancelling game:", error);
                 alert(`Error cancelling game: ${error.message}`);
                 showModeSelection();
             }
         }

        function startListeningForGameUpdates(gameId) {
             cleanupSubscription();

             console.log("Starting to listen for updates on game:", gameId);
             // Use supabaseClient (Corrected)
             gameSubscription = supabaseClient.channel(`chess_game_${gameId}`)
                 .on('postgres_changes',
                     { event: 'UPDATE', schema: 'public', table: 'chess_games', filter: `id=eq.${gameId}` },
                     payload => {
                         console.log('Received game update via subscription:', payload.new);
                         handleGameUpdate(payload.new);
                     }
                 )
                 .subscribe((status, err) => {
                     if (status === 'SUBSCRIBED') {
                         console.log('Successfully subscribed to game updates!');
                     } else if (status === 'CHANNEL_ERROR' || status === 'TIMED_OUT' || status === 'CLOSED') {
                         console.error('Subscription error/closed:', status, err);
                         alert("Connection to game updates lost. Please refresh the page to reconnect.");
                         cleanupSubscription(); // Attempt cleanup on error
                     }
                 });
         }

        function cleanupSubscription() {
            if (gameSubscription) {
                console.log("Removing previous game subscription.");
                // Use supabaseClient (Corrected)
                supabaseClient.removeChannel(gameSubscription)
                    .then(status => console.log("Subscription remove status:", status))
                    .catch(error => console.error("Error removing subscription:", error));
                gameSubscription = null;
            }
        }

        function handleGameUpdate(newState) {
            console.log("Handling game update. Current local player:", playerColor);
            console.log("New state received:", newState);

             // Prevent updates if we are not in friend mode or gameArea is hidden (e.g., back on mode select)
            if (gameMode !== 'friend' || gameAreaDiv.classList.contains('hidden')) {
                 console.log("Skipping update handler - not in friend mode or game area hidden.");
                 return;
            }

            // Check if game just became active (P2 joined) and this player is P1
            if (newState.game_status === 'active' && playerColor === 'white' && !player2Name) {
                 console.log("Opponent joined!");
                 // Creator (White) was waiting, now load the game
                 initGame(newState); // This hides waiting screen and shows board
                 return; // initGame calls prepareTurn
            }

            // Update local state from Supabase data ONLY if game is active or finished
            if (newState.game_status !== 'waiting') {
                 board = deserializeBoard(newState.board_state);
                 currentPlayer = newState.current_turn;
                 castlingRights = (newState.castling_rights && typeof newState.castling_rights === 'object')
                                  ? newState.castling_rights
                                  : JSON.parse(JSON.stringify(initialCastlingRights));
                 enPassantTarget = newState.en_passant_target;
                 player1Name = newState.player_white_name || 'White';
                 player2Name = newState.player_black_name || 'Black'; // Update P2 name if it changed
                 gameOver = determineGameOverStatus(newState.game_status, newState.winner); // Important: update gameOver status

                 console.log("Local state updated from subscription:", { currentPlayer, playerColor, gameOver });

                 // Re-calculate derived state and render
                 prepareTurn();
            } else {
                 console.log("Received update for game still in 'waiting' state - likely P1 update before P2 joined.");
                 // Could update P1 name display if needed, but generally ignore board updates etc.
                 player1Name = newState.player_white_name || 'White'; // Update just in case
                 waitingMessage.textContent = `Game created by ${player1Name}. Waiting for opponent...`;
            }
         }

         function determineGameOverStatus(status, winner) {
            switch (status) {
                case 'checkmate_white': return `Checkmate! ${player1Name} (White) wins.`; // Use names
                case 'checkmate_black': return `Checkmate! ${player2Name} (Black) wins.`; // Use names
                case 'stalemate': return "Stalemate! It's a draw.";
                case 'draw_agreement': return "Draw by agreement."; // Not implemented
                case 'aborted': return "Game aborted.";
                // Add other draw conditions if implemented
                case 'active':
                case 'waiting':
                default:
                    return false; // Game is not over
            }
         }

        // --- Core Chess Logic ---

        function createLabels() {
            const files = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const ranks = ['8', '7', '6', '5', '4', '3', '2', '1'];
            topFilesLabel.innerHTML = ''; bottomFilesLabel.innerHTML = ''; leftRanksLabel.innerHTML = ''; rightRanksLabel.innerHTML = '';
            // Flip labels if board is flipped
            const displayFiles = (gameMode === 'friend' && playerColor === 'black') ? [...files].reverse() : files;
            const displayRanks = (gameMode === 'friend' && playerColor === 'black') ? [...ranks].reverse() : ranks;

            displayFiles.forEach(file => { const tl = document.createElement('div'); tl.classList.add('label'); tl.textContent = file; topFilesLabel.appendChild(tl); const bl = document.createElement('div'); bl.classList.add('label'); bl.textContent = file; bottomFilesLabel.appendChild(bl); });
            displayRanks.forEach(rank => { const ll = document.createElement('div'); ll.classList.add('label'); ll.textContent = rank; leftRanksLabel.appendChild(ll); const rl = document.createElement('div'); rl.classList.add('label'); rl.textContent = rank; rightRanksLabel.appendChild(rl); });
        }

        function prepareTurn() {
            console.log(`prepareTurn START: CurrentPlayer=${currentPlayer}, PlayerColor=${playerColor}, GameOver=${gameOver}, IsMyTurn=${isMyTurn}`);
            selectedPiece = null;
            validMoves = [];
            updateCheckStatus(); // Check if current player is in check based on current board

            // Determine if it's this browser's player's turn
            isMyTurn = !gameOver && (gameMode === 'self' || (gameMode === 'friend' && currentPlayer === playerColor));
            console.log(`prepareTurn: Is my turn now? ${isMyTurn}`);

            // Find clickable pieces *only if* it's my turn and game not over
            initialClickablePieces = (isMyTurn && !gameOver) ? findClickablePieces() : [];
            console.log(`prepareTurn: Found ${initialClickablePieces.length} clickable pieces.`);

            // Check for game end (checkmate/stalemate) based on the current state.
            // This needs to run for both players AFTER state updated to display correctly.
            // But game over status should primarily be determined by received state in friend mode.
             if (!gameOver && gameMode === 'self') {
                // In self-play, recalculate game end based on local logic
                checkGameEndLocally();
             } else if (gameOver) {
                 // If game over state received from Supabase, ensure listener is removed
                 chessboardElement.removeEventListener('click', handleSquareClick);
             }


            // Update status display (whose turn, check, game over)
            updateStatusDisplay();

            // Render the board based on the new state
            renderBoard();
             console.log(`prepareTurn END: CurrentPlayer=${currentPlayer}, PlayerColor=${playerColor}, GameOver=${gameOver}, IsMyTurn=${isMyTurn}`);
        }

        function renderBoard() {
            chessboardElement.innerHTML = ''; // Clear previous state

            const boardIsFlipped = (gameMode === 'friend' && playerColor === 'black');

            for (let r_disp = 0; r_disp < 8; r_disp++) { // Display row
                for (let c_disp = 0; c_disp < 8; c_disp++) { // Display col
                    const r = boardIsFlipped ? 7 - r_disp : r_disp;
                    const c = boardIsFlipped ? 7 - c_disp : c_disp;

                    const piece = board[r]?.[c];
                    if (typeof board[r] === 'undefined') {
                        console.error(`Error accessing board row ${r} (Display: ${r_disp})`); continue;
                    }

                    let element;
                    let isSelectable = false; // Can this piece be selected?
                    let isSelected = false; // Is this the currently selected piece?
                    let isValidTarget = false; // Is this a valid move target square?
                    let isCaptureTarget = false; // Is this a capture target?

                    // Determine interaction states ONLY if it's my turn and game isn't over
                    if (!gameOver && isMyTurn) {
                        if (selectedPiece) {
                            if (r === selectedPiece.row && c === selectedPiece.col) {
                                isSelectable = true;
                                isSelected = true;
                            } else {
                                isValidTarget = validMoves.some(move => move.row === r && move.col === c);
                                if (isValidTarget) {
                                    isSelectable = true;
                                    isCaptureTarget = piece !== null ||
                                        (selectedPiece.piece.type === 'pawn' && c !== selectedPiece.col && piece === null && enPassantTarget && r === enPassantTarget.row && c === enPassantTarget.col);
                                }
                            }
                        } else {
                            isSelectable = initialClickablePieces.some(p => p.row === r && p.col === c);
                        }
                    }

                    element = document.createElement(isSelectable ? 'button' : 'div');
                    element.classList.add('square-base');
                    element.classList.add(isSelectable ? 'square-button' : 'square-div');
                    element.classList.add((r + c) % 2 === 0 ? 'light' : 'dark');
                    element.dataset.row = r; // Store logical row/col
                    element.dataset.col = c;

                    const notation = getNotation(r, c);
                    element.textContent = notation; // Visually hidden

                    if (piece) {
                        element.dataset.pieceSymbol = piece.unicode;
                        element.classList.add(piece.color);
                        element.classList.add('has-piece');
                    }

                    if (isSelectable) {
                        if (isSelected) {
                            element.classList.add('selected');
                        } else if (isValidTarget) {
                            element.classList.add(isCaptureTarget ? 'capture-move' : 'valid-move');
                        }
                    }

                    chessboardElement.appendChild(element);
                }
            }

            // Event listener management (delegation)
            chessboardElement.removeEventListener('click', handleSquareClick);
            if (!gameOver && isMyTurn) { // Only add listener if game active and it's my turn
                 chessboardElement.addEventListener('click', handleSquareClick);
            }
        }

        function handleSquareClick(event) {
            const targetButton = event.target.closest('.square-button');
            if (!targetButton || !isMyTurn || gameOver) return; // Ignore if not interactive

            const row = parseInt(targetButton.dataset.row);
            const col = parseInt(targetButton.dataset.col);
            if (isNaN(row) || isNaN(col)) return;

            if (selectedPiece) {
                if (row === selectedPiece.row && col === selectedPiece.col) { // Deselect
                    selectedPiece = null;
                    validMoves = [];
                    renderBoard(); // Re-render to show initial pieces selectable
                } else {
                    const isTarget = validMoves.some(move => move.row === row && move.col === col);
                    if (isTarget) { // Make the move
                        const fromRow = selectedPiece.row;
                        const fromCol = selectedPiece.col;
                        const pieceToMove = selectedPiece.piece;

                        let promotionPiece = null;
                        if (pieceToMove.type === 'pawn' && (row === 0 || row === 7)) {
                            // Auto-Queen for simplicity, could add prompt
                             promotionPiece = pieceToMove.color === 'white' ? 'Q' : 'q';
                        }

                        if (gameMode === 'self') {
                            const moveSuccessful = makeMove(fromRow, fromCol, row, col, promotionPiece);
                             if (moveSuccessful) {
                                 switchPlayer();
                                 prepareTurn(); // Recalculate and re-render for next turn
                             }
                        } else if (gameMode === 'friend') {
                            // Disable interaction immediately and send move
                            isMyTurn = false; // Prevent further clicks locally until update received
                            chessboardElement.removeEventListener('click', handleSquareClick); // Remove listener
                            renderBoard(); // Re-render to show board without interaction highlights
                            sendMoveToSupabase(fromRow, fromCol, row, col, promotionPiece);
                        }
                    } else { // Clicked another of my pieces?
                         const clickedPieceData = board[row]?.[col];
                         if (clickedPieceData && clickedPieceData.color === currentPlayer && initialClickablePieces.some(p => p.row === row && p.col === col) ) {
                             // Select the new piece
                             selectPiece(clickedPieceData, row, col);
                             renderBoard(); // Re-render with new selection
                         } else {
                              // Clicked an invalid square (opponent, empty non-target) -> Deselect
                              selectedPiece = null;
                              validMoves = [];
                              renderBoard();
                         }
                    }
                }
            } else { // No piece selected, clicked an initial clickable piece
                const clickedPieceData = board[row]?.[col];
                if (clickedPieceData && clickedPieceData.color === currentPlayer) {
                     selectPiece(clickedPieceData, row, col); // Select the piece
                     renderBoard(); // Re-render to show selection and moves
                }
            }
        }

        function selectPiece(pieceData, row, col) {
             selectedPiece = { piece: pieceData, row, col };
             // Calculate valid moves, filtering out moves that leave the king in check
             const potentialMoves = calculateValidMoves(pieceData, row, col, board, castlingRights, enPassantTarget);
             validMoves = potentialMoves.filter(move => {
                 // Use current game state for simulation context
                 const tempBoard = simulateMove(row, col, move.row, move.col, board, enPassantTarget);
                 return !isKingInCheck(currentPlayer, tempBoard);
             });
             console.log(`Selected ${pieceData.type} at ${getNotation(row,col)}. Valid moves:`, validMoves.map(m => getNotation(m.row, m.col)));
        }

        function makeMove(fromRow, fromCol, toRow, toCol, promotionPieceKey = null) {
            const pieceToMove = board[fromRow]?.[fromCol];
            if (!pieceToMove) { console.error("MakeMove Error: No piece at source", fromRow, fromCol); return false; }

            const capturedPiece = board[toRow]?.[toCol];
            let specialMove = null;
            let capturedEnPassant = false;

            // 1. Handle En Passant Capture Victim
            if (pieceToMove.type === 'pawn' && enPassantTarget && toRow === enPassantTarget.row && toCol === enPassantTarget.col && !capturedPiece) {
                const capturedPawnRow = currentPlayer === 'white' ? toRow + 1 : toRow - 1;
                if(board[capturedPawnRow]?.[toCol]?.type === 'pawn'){
                     board[capturedPawnRow][toCol] = null;
                     capturedEnPassant = true; specialMove = 'enpassant';
                     console.log("En passant capture executed.");
                }
            }

            // 2. Reset En Passant Target for the *next* turn
            let nextEnPassantTarget = null;

            // 3. Handle Castling Rook Move
            if (pieceToMove.type === 'king' && Math.abs(toCol - fromCol) === 2) {
                specialMove = 'castling';
                const rookCol = toCol > fromCol ? 7 : 0;
                const rookTargetCol = toCol > fromCol ? 5 : 3;
                const rook = board[fromRow]?.[rookCol];
                if (rook?.type === 'rook') {
                    board[fromRow][rookTargetCol] = rook;
                    board[fromRow][rookCol] = null;
                    console.log("Castling: Rook moved.");
                } else { console.error("Castling Error: Rook not found at", fromRow, rookCol); }
            }

            // 4. Move the main piece
            board[toRow][toCol] = pieceToMove;
            board[fromRow][fromCol] = null;

            // 5. Set New En Passant Target (if Pawn moved two squares)
            if (pieceToMove.type === 'pawn' && Math.abs(toRow - fromRow) === 2) {
                nextEnPassantTarget = { row: (fromRow + toRow) / 2, col: fromCol };
                 console.log("New en passant target set:", nextEnPassantTarget);
            }
            // Update the global enPassantTarget state *after* checking for captures
            enPassantTarget = nextEnPassantTarget;

            // 6. Update Castling Rights (create new object to avoid mutation issues)
            const newCastlingRights = JSON.parse(JSON.stringify(castlingRights)); // Deep copy
            const playerColorMoved = pieceToMove.color;
            let rightsChanged = false;

            if (pieceToMove.type === 'king') {
                if (newCastlingRights[playerColorMoved]?.kingSide || newCastlingRights[playerColorMoved]?.queenSide) {
                    newCastlingRights[playerColorMoved] = { kingSide: false, queenSide: false };
                    rightsChanged = true; console.log(`Castling rights revoked for ${playerColorMoved} (king move).`);
                }
            } else if (pieceToMove.type === 'rook') {
                const startRow = playerColorMoved === 'white' ? 7 : 0;
                if (fromRow === startRow) {
                    if (fromCol === 0 && newCastlingRights[playerColorMoved]?.queenSide) {
                        newCastlingRights[playerColorMoved].queenSide = false; rightsChanged = true; console.log(`Castling rights revoked for ${playerColorMoved} Q-side (rook move).`);
                    } else if (fromCol === 7 && newCastlingRights[playerColorMoved]?.kingSide) {
                        newCastlingRights[playerColorMoved].kingSide = false; rightsChanged = true; console.log(`Castling rights revoked for ${playerColorMoved} K-side (rook move).`);
                    }
                }
            }
            if (capturedPiece?.type === 'rook') {
                const capturedColor = capturedPiece.color;
                const capturedStartRow = capturedColor === 'white' ? 7 : 0;
                if (toRow === capturedStartRow) { // Check if rook was captured on its starting rank
                    if (toCol === 0 && newCastlingRights[capturedColor]?.queenSide) {
                        newCastlingRights[capturedColor].queenSide = false; rightsChanged = true; console.log(`Castling rights revoked for ${capturedColor} Q-side (rook capture).`);
                    } else if (toCol === 7 && newCastlingRights[capturedColor]?.kingSide) {
                        newCastlingRights[capturedColor].kingSide = false; rightsChanged = true; console.log(`Castling rights revoked for ${capturedColor} K-side (rook capture).`);
                    }
                }
            }
            if (rightsChanged) {
                castlingRights = newCastlingRights; // Update global state only if changed
            }

            // 7. Handle Promotion
            if (promotionPieceKey && PIECES[promotionPieceKey]) {
                board[toRow][toCol] = { ...PIECES[promotionPieceKey] };
                specialMove = 'promotion';
                console.log(`Pawn promoted to ${PIECES[promotionPieceKey].type}`);
            }

            console.log(`Move made: ${playerColorMoved} ${pieceToMove.type} ${getNotation(fromRow, fromCol)}->${getNotation(toRow, toCol)}${capturedPiece ? 'x'+capturedPiece.type : ''}${capturedEnPassant ? ' (ep)' : ''}${specialMove === 'castling' ? ' (castle)' : ''}${specialMove === 'promotion' ? '='+promotionPieceKey : ''}`);
             return true; // Move successful
        }

        function switchPlayer() {
            currentPlayer = (currentPlayer === 'white') ? 'black' : 'white';
            console.log("Switched player to:", currentPlayer);
        }

        function updateStatusDisplay() {
            let statusText = "";
            let infoText = "";

            if (gameOver) {
                statusText = gameOver;
                statusElement.style.color = 'red';
                 infoText = `Game Over`;
                 if (gameMode === 'friend') infoText += ` - ${player1Name} vs ${player2Name}`;
            } else {
                const turnPlayerName = currentPlayer === 'white' ? player1Name : player2Name;
                statusText = `${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}'s turn`;
                 if (gameMode === 'friend') statusText = `${turnPlayerName}'s turn (${currentPlayer})`;


                if (checkStatus[currentPlayer]) {
                    statusText += " (Check!)";
                    statusElement.style.color = 'orange';
                } else {
                    statusElement.style.color = '#333'; // Default color
                }

                if (gameMode === 'friend') {
                    infoText = `${player1Name} (W) vs ${player2Name} (B)`;
                     if (isMyTurn) {
                         statusText = `Your turn (${playerColor})` + (checkStatus[currentPlayer] ? " (Check!)" : "");
                         infoText += " - Your move";
                         document.title = "* Web Chess - Your Turn!"; // Notify in title
                     } else {
                         const opponentColor = playerColor === 'white' ? 'black' : 'white';
                         const opponentName = opponentColor === 'white' ? player1Name : player2Name;
                         statusText = `${opponentName}'s turn (${opponentColor})` + (checkStatus[currentPlayer] ? " (Check!)" : "");
                         infoText += ` - Waiting for opponent`;
                         document.title = "Web Chess - Opponent's Turn";
                     }
                } else {
                     infoText = "Self-Play Mode";
                     document.title = `Web Chess - ${currentPlayer}'s Turn`;
                }
            }
            statusElement.textContent = statusText;
            infoElement.textContent = infoText;
        }


        // --- Rule Calculations (Helper functions) ---

        // Finds pieces for the *current* player that have legal moves
        function findClickablePieces() {
            return findClickablePiecesForPlayer(currentPlayer, board, castlingRights, enPassantTarget);
        }

        // Generic version to find clickable pieces for a specific player/board state
         function findClickablePiecesForPlayer(player, currentBoard, currentCastlingRights, currentEnPassantTarget) {
            const clickable = [];
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = currentBoard[r]?.[c];
                    if (piece && piece.color === player) {
                        if (hasAnyValidMovesForPiece(piece, r, c, player, currentBoard, currentCastlingRights, currentEnPassantTarget)) {
                            clickable.push({ row: r, col: c });
                        }
                    }
                }
            }
             // console.log(`Clickable pieces for ${player}:`, clickable.map(p => getNotation(p.row, p.col)));
            return clickable;
        }

        // Checks if a specific piece has any moves that don't leave its king in check
        function hasAnyValidMovesForPiece(piece, row, col, player, currentBoard, currentCastlingRights, currentEnPassantTarget) {
            const potentialMoves = calculateValidMoves(piece, row, col, currentBoard, currentCastlingRights, currentEnPassantTarget);
            for (const move of potentialMoves) {
                const tempBoard = simulateMove(row, col, move.row, move.col, currentBoard, currentEnPassantTarget);
                 if (!isKingInCheck(player, tempBoard)) {
                    return true; // Found at least one legal move
                }
            }
            return false; // No legal moves found for this piece
        }

        // Calculate potential moves (doesn't check for check safety here)
        function calculateValidMoves(piece, row, col, currentBoard, currentCastlingRights, currentEnPassantTarget) {
             const moves = [];
             const color = piece.color;
             const opponentColor = (color === 'white') ? 'black' : 'white';

             const addMove = (r, c) => { /* ... same as before ... */
                 if (!isValidSquare(r, c)) return false;
                 const targetPiece = currentBoard[r]?.[c];
                 if (targetPiece === null) { moves.push({ row: r, col: c }); return true; }
                 else if (targetPiece.color === opponentColor) { moves.push({ row: r, col: c }); return false; }
                 else { return false; } };
             const addPawnMove = (r, c) => { /* ... same as before ... */
                 if (isValidSquare(r, c) && currentBoard[r]?.[c] === null) { moves.push({ row: r, col: c }); return true; } return false; };
             const addPawnCapture = (r, c) => { /* ... same as before ... */
                 if (!isValidSquare(r, c)) return;
                 const targetPiece = currentBoard[r]?.[c];
                 if (targetPiece && targetPiece.color === opponentColor) { moves.push({ row: r, col: c }); }
                 else if (currentEnPassantTarget && r === currentEnPassantTarget.row && c === currentEnPassantTarget.col && targetPiece === null) {
                     const passantCaptureRank = color === 'white' ? 3 : 4; // Rank of PAWN being captured
                     const passantPawnRank = color === 'white' ? 4 : 3; // Rank of pawn doing the capturing
                     if (row === passantPawnRank) { // Ensure capturing pawn is on correct rank
                        moves.push({ row: r, col: c });
                     }
                 } };

             switch (piece.type) {
                 case 'pawn':
                     const dir = color === 'white' ? -1 : 1; const startRow = color === 'white' ? 6 : 1;
                     if (addPawnMove(row + dir, col)) { if (row === startRow) { addPawnMove(row + 2 * dir, col); } }
                     addPawnCapture(row + dir, col - 1); addPawnCapture(row + dir, col + 1); break;
                 case 'rook': case 'bishop': case 'queen':
                     const dirs = { 'rook': [[-1, 0], [1, 0], [0, -1], [0, 1]], 'bishop': [[-1, -1], [-1, 1], [1, -1], [1, 1]], 'queen': [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] }[piece.type];
                     dirs.forEach(([dr, dc]) => { let r = row + dr; let c = col + dc; while (addMove(r, c)) { r += dr; c += dc; } }); break;
                 case 'knight':
                     const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                     knightMoves.forEach(([dr, dc]) => { addMove(row + dr, col + dc); }); break;
                 case 'king':
                     const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                     kingMoves.forEach(([dr, dc]) => { addMove(row + dr, col + dc); });
                     // Castling
                     if (currentCastlingRights?.[color] && !isKingInCheck(color, currentBoard)) { // Use current state
                         if (currentCastlingRights[color].kingSide && currentBoard[row]?.[col + 1] === null && currentBoard[row]?.[col + 2] === null && currentBoard[row]?.[col + 3]?.type === 'rook' && currentBoard[row]?.[col + 3]?.color === color &&
                             !isSquareAttacked(row, col, opponentColor, currentBoard) && !isSquareAttacked(row, col + 1, opponentColor, currentBoard) && !isSquareAttacked(row, col + 2, opponentColor, currentBoard)) {
                             moves.push({ row: row, col: col + 2 });
                         }
                         if (currentCastlingRights[color].queenSide && currentBoard[row]?.[col - 1] === null && currentBoard[row]?.[col - 2] === null && currentBoard[row]?.[col - 3] === null && currentBoard[row]?.[col - 4]?.type === 'rook' && currentBoard[row]?.[col - 4]?.color === color &&
                             !isSquareAttacked(row, col, opponentColor, currentBoard) && !isSquareAttacked(row, col - 1, opponentColor, currentBoard) && !isSquareAttacked(row, col - 2, opponentColor, currentBoard)) {
                             moves.push({ row: row, col: col - 2 });
                         }
                     }
                     break;
             }
             return moves;
         }

         // --- Check and Game End Logic ---
         function updateCheckStatus() {
             checkStatus.white = isKingInCheck('white', board);
             checkStatus.black = isKingInCheck('black', board);
             // console.log("Check status updated:", checkStatus);
         }

         // Only used in self-play mode now to determine end locally
         function checkGameEndLocally() {
             if (initialClickablePieces.length === 0) {
                 if (checkStatus[currentPlayer]) {
                     gameOver = `Checkmate! ${currentPlayer === 'white' ? player2Name + ' (Black)' : player1Name + ' (White)'} wins.`;
                     console.log(gameOver);
                 } else {
                     gameOver = "Stalemate! It's a draw.";
                     console.log(gameOver);
                 }
                 chessboardElement.removeEventListener('click', handleSquareClick); // Remove listener on game end
                 return true;
             }
             // Game is not over locally
             // Ensure gameOver is false if game continues (it might have been set true previously)
              if (gameOver) { // If it was previously game over but isn't now (e.g. reset?)
                   gameOver = false;
               }
             return false;
         }

         // --- Utility Functions ---
         function isValidSquare(row, col) { return row >= 0 && row < 8 && col >= 0 && col < 8; }
         function getNotation(row, col) { if (!isValidSquare(row, col)) return "??"; const file = String.fromCharCode(97 + col); const rank = 8 - row; return file + rank; }
         function findKing(color, currentBoard) { /* ... same as before ... */
             for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const piece = currentBoard[r]?.[c]; if (piece && piece.type === 'king' && piece.color === color) { return { row: r, col: c }; } } }
             console.error(`King of color ${color} not found!`); return null; }

         function isKingInCheck(kingColor, currentBoard) { /* ... same as before ... */
             const kingPos = findKing(kingColor, currentBoard); if (!kingPos) return false;
             const opponentColor = (kingColor === 'white') ? 'black' : 'white';
             return isSquareAttacked(kingPos.row, kingPos.col, opponentColor, currentBoard); }

         function isSquareAttacked(targetRow, targetCol, attackerColor, currentBoard) { /* ... same as before ... */
             for (let r = 0; r < 8; r++) { for (let c = 0; c < 8; c++) { const piece = currentBoard[r]?.[c]; if (piece && piece.color === attackerColor) {
                 const rawAttacks = calculateRawAttacks(piece, r, c, currentBoard);
                 if (rawAttacks.some(attack => attack.row === targetRow && attack.col === targetCol)) { return true; } } } } return false; }

        // Calculates squares a piece attacks (raw, ignores check safety)
        // CORRECTED version for sliding pieces
        function calculateRawAttacks(piece, row, col, currentBoard) {
             const attacks = [];
             const color = piece.color;

             const addPawnAttack = (r, c) => { if (isValidSquare(r, c)) { attacks.push({ row: r, col: c }); } };

             switch (piece.type) {
                 case 'pawn':
                     const dir = color === 'white' ? -1 : 1;
                     addPawnAttack(row + dir, col - 1);
                     addPawnAttack(row + dir, col + 1);
                     break;
                 case 'rook':
                 case 'bishop':
                 case 'queen':
                     const dirs = { 'rook': [[-1, 0], [1, 0], [0, -1], [0, 1]], 'bishop': [[-1, -1], [-1, 1], [1, -1], [1, 1]], 'queen': [[-1, 0], [1, 0], [0, -1], [0, 1], [-1, -1], [-1, 1], [1, -1], [1, 1]] }[piece.type];
                     // CORRECTED Sliding Logic (based on original)
                     dirs.forEach(([dr, dc]) => {
                         let r = row + dr;
                         let c = col + dc;
                         // Check and add the *first* square in the direction
                         if (isValidSquare(r, c)) {
                             attacks.push({ row: r, col: c });
                             // Only continue sliding if the first square was empty AND the *next* square is valid
                             while (currentBoard[r]?.[c] === null && isValidSquare(r + dr, c + dc)) {
                                 r += dr;
                                 c += dc;
                                 attacks.push({ row: r, col: c });
                             }
                         }
                     });
                     break;
                 case 'knight':
                     const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
                     knightMoves.forEach(([dr, dc]) => { if (isValidSquare(row + dr, col + dc)) { attacks.push({ row: row + dr, col: col + dc }); } });
                     break;
                 case 'king':
                     const kingMoves = [[-1, -1], [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0], [1, 1]];
                     kingMoves.forEach(([dr, dc]) => { if (isValidSquare(row + dr, col + dc)) { attacks.push({ row: row + dr, col: col + dc }); } });
                     break;
             }
             return attacks;
         }


         // Creates a temporary board state after a hypothetical move
         function simulateMove(fromRow, fromCol, toRow, toCol, currentBoard, currentEnPassantTarget) {
             // Use the passed board state for simulation
             const tempBoard = currentBoard.map(row => row.map(p => p ? { ...p } : null));
             const piece = tempBoard[fromRow]?.[fromCol];
             if (!piece) { return tempBoard; } // Return copy if no piece

             // Simulate En Passant capture removal
             if (piece.type === 'pawn' && currentEnPassantTarget && toRow === currentEnPassantTarget.row && toCol === currentEnPassantTarget.col && tempBoard[toRow]?.[toCol] === null) {
                 const capturedPawnRow = piece.color === 'white' ? toRow + 1 : toRow - 1;
                 if (tempBoard[capturedPawnRow]?.[toCol]) tempBoard[capturedPawnRow][toCol] = null;
             }

             // Simulate Castling rook move
             if (piece.type === 'king' && Math.abs(toCol - fromCol) === 2) {
                 const rookCol = toCol > fromCol ? 7 : 0;
                 const rookTargetCol = toCol > fromCol ? 5 : 3;
                 if (tempBoard[fromRow]?.[rookCol]) {
                     tempBoard[fromRow][rookTargetCol] = tempBoard[fromRow][rookCol];
                     tempBoard[fromRow][rookCol] = null;
                 }
             }

             // Move the main piece
             tempBoard[toRow][toCol] = piece;
             tempBoard[fromRow][fromCol] = null;

             // Simulate Promotion (assume Queen)
             if (piece.type === 'pawn' && (toRow === 0 || toRow === 7)) {
                 const promotedPieceKey = piece.color === 'white' ? 'Q' : 'q';
                 tempBoard[toRow][toCol] = { ...PIECES[promotedPieceKey] };
             }

             return tempBoard;
         }

        // --- Event Listeners ---
        selfPlayButton.addEventListener('click', () => {
            gameMode = 'self';
            initGame();
        });

        friendPlayButton.addEventListener('click', showFriendSetup);
        backToModeSelectionButton1.addEventListener('click', showModeSelection);
        createGameButton.addEventListener('click', createSupabaseGame);

        copyLinkButton.addEventListener('click', () => {
            shareLinkInput.select();
            try {
                navigator.clipboard.writeText(shareLinkInput.value)
                    .then(() => alert('Link copied to clipboard!'))
                    .catch(err => { console.error('Copy failed: ', err); alert('Copy failed. Please copy manually.'); });
            } catch (err) { // Fallback for older browsers
                 try { document.execCommand('copy'); alert('Link copied (fallback)!'); }
                 catch (e) { console.error('Fallback copy failed: ', e); alert('Copy failed. Please copy manually.'); }
            }
        });

         cancelGameButton.addEventListener('click', cancelSupabaseGame);

        resetButton.addEventListener('click', () => {
            if (gameMode === 'self') {
                 if(confirm("Reset the game?")) { initGame(); }
            } else { alert("Reset is disabled in 'Play with Friend' mode."); }
        });

        // --- Initial Load Logic ---
        window.addEventListener('load', () => {
            console.log("Page loaded. Hash:", window.location.hash);
            const hash = window.location.hash;
            if (hash && hash.startsWith('#gameId=')) {
                const gameId = hash.substring(8);
                 if (gameId && /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/.test(gameId)) { // Basic UUID check
                     // Use setTimeout to ensure Supabase client might be fully ready and avoid race conditions
                     setTimeout(() => joinSupabaseGame(gameId), 150);
                 } else {
                     console.error("Invalid gameId format in hash:", gameId);
                     showModeSelection();
                 }
            } else {
                showModeSelection();
            }
             // Clean the hash after processing
             // history.replaceState(null, null, window.location.pathname + window.location.search); // Optional: Remove #gameId from URL
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', (event) => {
             // Standard way to prompt user before leaving if game is active?
             // if (gameMode === 'friend' && currentGameId && !gameOver) {
             //    event.preventDefault(); // Standard requires this
             //    event.returnValue = ''; // Chrome requires this
             // }
            cleanupSubscription(); // Always try to clean up subscription
        });

    </script>
</body>
</html>